---
layout: post
category : interview
tagline: "Supporting tagline"
tags : [tree]
---
{% include JB/setup %}

* dir
{:toc}


## Overview
{:.no_toc}

二叉树在数据结构面试中的低位可谓举足轻重，因为对于二叉树操作直接反应出一个人的数据结构的功底有多深，基础知识是否扎实。


二叉树的基本数据结构:
{% highlight C linenos %}
typedef struct _Node{
	int		val;
	struct _Node *left,*right;
}BinTreeNode;
{% endhighlight %}


### 1.二叉树的基本性质

 + 在二叉树的第i层`至多`有2<sup>(i-1)</sup>个节点(i>=1)
 + 深度为k的二叉树`最多`有2<sup>k</sup>-1个节点(k>=1)
 + 一棵二叉树的叶子节点数为n<sub>2</sub>,度为2的节点为n<sub>2</sub>，则<font color="red">n<sub>0</sub> = n<sub>2</sub> + 1</font>.
 + 具有n个节点的完全二叉树的深度为<font color="red">Floor(Log<sub>2</sub>n)+1.</font>
 + 如果对一棵有n个节点完全二叉树的节点按照层次编号，对于任意节点i(1=<i<=n)

{% highlight C linenos %}

如果i=1,则节点i是二叉树的根，无双亲；如果i > 1，则其双亲节点是Floor(i/2);
如果2*i > n,则节点i无左孩子，否则其左孩子的节点是2*i;
如果2*i + 1 > n,则节点无右孩子;否则其右孩子的节点是2*i+1.
{% endhighlight %}


### 2.建立二叉树

### 3.递归遍历二叉树(先序，中序，后序)

+ 二叉树的先序遍历
二叉树的先序遍历(根左右)

code:
{% highlight C linenos %}
void PreTravel(BinTreeNode *root)
{
	if(!root){
		printf("%d",root->val);
		PreTravel(root->left);
		PreTravel(root->right);
	}
}
{% endhighlight %}

+ 二叉树的中序遍历
二叉树的先序遍历(左根右)

code:
{% highlight C linenos %}
void InTravel(BinTreeNode *root)
{
	if(!root){
		printf("%d",root->val);
		PreTravel(root->left);
		PreTravel(root->right);
	}
}
{% endhighlight %}

+ 二叉树的后序遍历
二叉树的先序遍历(左右根)

code:
{% highlight C linenos %}
void PostTravle(BinTreeNode *root)
{
	if(!root){
		PreTravel(root->left);
		PreTravel(root->right);
		printf("%d",root->val);
	}
}

{% endhighlight %}

### 4.非递归遍历二叉树(先序，中序，后序)

### 5.二叉树的节点个数

### 6.二叉树的深度

### 7.二叉树的层次遍历

### 8.二叉树第K层的节点个数

### 9.二叉树的镜像

### 10.二叉树中和为某一值的路径

### 11.树中两个节点的最低公共祖先

### 12.树的子结构

### 13.之字形打印二叉树

### 14.对称二叉树

### 15.二叉树的下一个节点

### 16.和为定值的全部路径

### 17.由中序和前序得到后序

### 18.二叉树搜索树的后序遍历


