---
layout: post
category : C++
tagline: "Supporting tagline"
tags : [interview C++]
---
{% include JB/setup %}


# Overview
{:.no_toc}


* dir
{:toc}

# `C++ basic `

## C++与C的不同

## C++main函数之后要执行的函数


## 定义宏得到一个字的高位和低位

## define 得到一年中有多少秒

## const和宏的区别

## C++中const的作用

## static有什么作用

## static 全局变量与普通的全局遍历的区别


## sizeof和strlen的区别

## sizeof有哪些用途

## inline和宏的区别

## 指针和引用的区别

## 为什么传引用比传指针安全

## 复杂指针的声明

## 指针常量和常量指针的区别

## 指针数组和数组指针

## 函数指针和指针函数

## 各种指针的定义

## typedef用于定义函数指针的含义

## 什么是野指针

## 有了malloc/free,为什么还要new/delete

## 动态内存的传递

## 内存的分配方法有几种

## 指针和句柄有什么区别


# `chars`

## 不使用库函数将整数转换为字符串

## 实现strcpy函数

## 实现memcpy函数

## strcpy与memcpy的区别

## 字符串的字串查找

## 字串中各个单词的翻转

## 字符串是否是回文

## 实现strcmp函数

## 查找两个字符串的最大公共子串

## 将十进制的数，转换为二进制和十六进制

## 实现任意长度的两个正整数相加

## 实现strcat函数

## C++中的4中运算符转化以及他们的不同点

## 关键字volatile的作用

## 如何判断处理器是大端还是小端

# `C++ Object`

## 描述面向对象技术的基本概念

## class和struct的区别

## 与全局对象相比，使用静态数据成员有什么优势

## 初始化列表不能用assignment

## main函数执行前还会执行什么代码

## C++默认的空类会产生哪些类成员函数

## explicit构造函数与普通构造函数的区别

## 复制构造函数是什么?什么是深复制和浅复制

## 复制构造函数与赋值函数有什么区别

## 编写String的构造函数，析构函数和赋值函数

## 为什么c不支持重载而c++支持

## 重载和重写的区别

## 私有继承和组合有什么相同点和不同点。

## 什么是多态

## 虚函数是怎么实现的

## 多继承的构造函数的顺序

 + 1.任何虚拟基类的构造函数按照他们被继承的顺序构造
 + 2.任何非虚拟的构造函数按照他们的被构造的顺序构造
 + 3.任何成员对象的构造函数按照他们声明的顺序调用
 + 4.类自身的构造函数

## 为什么要引入抽象基类和纯虚函数

## 虚函数和纯虚函数有什么区别

## 构造二叉排序树

## `泛型编程`

##  什么是泛型编程

泛型编程编写完全一般化并可重复使用的算法，其效率与针对的某特定的数据类型而设定的算法相同。所谓的泛型，是指具有在数据类型上皆可操作的含义，在C++中实际上就是使用模板实现。

{% highlight C linenos %}
int max(int a,int b)
{
	return a>b?a:b;
}

float max(float a,float b)
{
	return a > b?a:b;
}

double max(double a,double b)
{
	return a > b?a:b;
}
// use template
template <typename T>
T max(T a,T b)
{
	return a > b? a:b;
}
{% endhighlight %}

## 函数模板和类模板分别是什么


类模板实例的个数由参数类型的种类决定的。

{% highlight C linenos %}
Array<int> arr1;
Array<char> arr2,arr3;
Array<int> arr4,arr8;
Array<double> arr5;
...
// 这里一共有3个实例。
{% endhighlight %}

## 使用模板有什么缺点？如何避免

## 解释什么是模板的特化

模板的特化(template specialization)分为两类：函数模板的特化和类模板的特化。
1.函数模板的特化：当函数模板需要对某些类型进行特别处理时，成为函数模板的特化.

##

##

##

## `STL`

STL的基本观念就是把数据和操作分离。

![image](http://lkkandsyf.github.com/pictures/stl.jpg)
STL中数据由容器类别类加以管理，操作则由可定制的算法来完成。迭代器的容器和算法之间当粘合剂，它使得任何算法都可以和任何容器进行交互运作。STL含有容器、算法、迭代器组件。

 + STL序列容器:vector,string,deque,list
 + STL关联容器:set,multiset,map,multimap
 + STL适配容器:stack,queue,priority_queue

## STL中如何实现vector

vector内部是使用动态数组的方式实现的，如果动态数组的内存不够用，就要动态的重新分配，一般是当前大小的两倍，然后把原来数组的内存copy过去，所以一般情况下，其访问速度同一般数组，只有在重新分配发生时，其性能才会下降。它的内部使用allocator类进行内存管理，程序员不需要自己操作内存。note: vector<type>::size_type 使用方法，定义的变量是unsigned int,切记访问的时候，需要特殊的考虑。对于arrar.erase(iter),每次调用的时候，被删除元素之后的内容会自动往前移动，导致迭代遗漏。

## list和vector有什么区别

vector和数组类似，它拥有一段连续的内存空间，并且起始地址不变，因此它能非常好的支持`随机存取`(使用[]操作符来访问其中的元素)。但由于它的内存空间是连续的，所以在中间进行`插入和删除`会造成内存快的copy(复杂度O(n))，另外，当该数组后的内存空间不够时，需要重新申请一块足够大的内存并进行内存的copy，这些都大大影响了vector的性能。

list是由数据结构中的双向链表实现的，因此它的内存空间是可以不连续的，因此只能`通过指针来进行访问数据`，这个特点使得它的`随机存取变得非常没有效率`，需要遍历中间的元素，搜索复杂度为O(n)，因此它没有提供[]操作符的重载，但是由于链表的特点，它可以以很好的效率支持`任意地方的删除和插入`。
note:如果需要高效的随机存取，而不在乎插入和删除的效率，就可以使用vector；如果需要大量的插入和删除，而不关心随机存取，则应使用list。

vector拥有一段`连续的内存空间`，因此`支持随机存取`，如果需要高效的`随机存取`，而`不在乎插入和删除的效率`，就使用vector。
list拥有一段`不连续的内存空间`，因此`不支持随机存取`，如果过需要`大量的插入和删除`,而`不在乎随机存取`，就使用list。

## 在做应用的时候，如何选择vector和deque

deque使用一段一段的定量内存，在进行内存扩充时，也只是加一段定量内存，因此不存在容量的概念，也就没有capacity()和reserve()成员函数。最后在插入操作，deque和vector有很大的不同，由于vector是一块连续的内存，所以插入的位置决定执行效率，位置越靠近数组首部，效率越低，而deque中的内存是分段连续的，因此在不同段中的插入效率都相同。

vector和deque的不同：内部数据管理不同。为了提高效率，vector在添加元素之前最好调用reserve()设置容量，而deque则不需要。
选择的方法，一般情况下选择vector，但当需要从首尾两端进行插入和删除元素操作的时候，应该选择deque。

## STL中的map内部如何实现，map和hashmap的区别

标准的STL关联容器(包括set和map以及set的衍生体multiset和map的衍生体multimap)的内部结构是一个平衡的二叉树，AVL-tree，RB-tree，AA-tree，STL的底层机制都是一红黑树完成的，每个结点都被着上了红色和黑色，结点的颜色被用来检测树的平衡性，在对结点进行插入和删除的操作，可能会被旋转树的平衡性，平均和最坏的情况下的插入、删除、查找的时间都是O(logn)
一个红黑树是一个平衡二叉树，除了二叉树带有的一般要求外，具有一下的属性。
 + 结点为红色或黑色
 + 所有叶子结点都是空结点，并且被着为黑色
 + 如果父结点是红色的，那么两个子结点都是黑色的
 + 结点到其子孙结点的每条简单路径上都包含相同的数目的黑色结点
 + 根结点是黑色

map和hashmap：
 + 底层数据结构不同，map是红黑树，hashmap是哈希表。
 + map的优点在与元素的可以自动按照键值排序，而hashmap的优点在于它的各项操作的平均时间复杂度接近常数。
 + map属于标准的一部分，而hashmap则不是。

## vector中的erase方法和algorithm中的remove有什么区别

 + vector中的erase是真正删除了元素，迭代器不能访问了。
 + 而algorithm中的remove只是简单的要把remove的元素移动到容器的后面，迭代器还是可以访问的，这是因为algorithm通过迭代器操作，不知容器的内部结构，所以无法做到真正的删除。


## 智能指针如何实现

## 使用std::auto_ptr 有什么方面的限制

 + auto_ptr要求一个对象只能有一个拥有者。
 + auto_ptr是不能以传值方式进行传递的。
 + 不支持数组
 + 注意Release，Release是释放指针，即交出指针的所有权。
 + auto_ptr在拷贝构造和=操作符的特殊意义决定了它不能为STL标准容器的成员。


`note:`函数对象，就是一个重载的`()`的运算符的类的对象，它可以像函数一样的使用。
{% highlight C linenos %}
minus <int> int_min;
cout << int_min(2,4) << endl; // -2
{% endhighlight %}
##

##

##

##

##

##

##

##

