---
layout: post
category : Scala
tagline: "Supporting tagline"
tags : [sbt]
---
{% include JB/setup %}

# Overview
{:.no_toc}

* dir
{:toc}

## sbt

### Installation


 + sbt:当你启动sbt命令时，假设不指定任何`任务`，SBT将启动一个`交互式REPL（REPL是 Read，Eval，Print，Loop的简写，代表了“读取-求值-打印-循环”）`。

运行sbt命令；>时SBT默认的交互式提示符，可以在#符号后编写sbt注释

	$sbt
	>help				# 描述命令
	>tasks				# 显示最常用的，当前可用的任务
	>tasks -V			# 显示所有的可用任务
	>compile			# 增量编译代码
	>test				# 增量编译代码，并执行测试
	>clean				# 删除所有已经编译好的构建
	>~test				# 一旦有文件保存，执行增量编译并运行测试
					# 适用于任何使用了～前缀的命令
	>console			# 运行Scala REPL
	>run				# 执行项目的某一程序
	>show x				# 显示变量X的定义
	>eclipse			# 生成Eclipse项目文件
	>exit				# 退出REPL(也可以通过ctrl+d的方式退出)
	>stylecheck			# 运行样式检查器
	>reload				# 重新加载构建定义（build.sbt， project/*.scala， project/*.sbt
						# 这些文件中定义的内容)。在修改了构建定义文件之后需要重新加载


为了能编译更新后的代码并运行对应测试，我通常会执行~test命令。SBT使用了`增量的编译器和测试执行器`，因此每次执行是不用等待完全构建所需时间。假如你`希望执行其他任务或者退出sbt`，只需要`按一下回车即可`。

使用Scala REPL能有效地对你编写的代码进行试验，也可以通过REPL来学习API，即便是JAVA API也是一样。在SBT上使用console任务执行代码时，console任务会很体贴地为你咋classpath中添加依赖项以及编译后的项目diamante

scaladoc:与javadoc不同，Scaladoc按照package来`排列类型`，而不是`按照字母顺序全部列出`.

`运行REPL的三种方式`
 + 可以不指定脚本或main参数来直接输入scala命令
 + 可以使用sbt console命令
 + 可以在那些流行的IDE中使用`worksheet`特性

解释器返回的是变量的`类型和数值`,可变数据是错误之源.


### Create a project

创建约定好的文件夹
```shell
touch build.sbt
mkdir -p src/main/resources	#存放jar，配置文件等
mkdir -p src/main/scala		#存放scala编写的代码文件
mkdir -p src/main/java		#存放java编写的代码文件
mkdir -p src/test/resources	#存放测试使用的jar，配置文件等
mkdir -p src/test/scala		#存放测试编写的scala代码的文件
mkdir -p src/test/java		#存放测试编写的java 代码的文件
```

在src/main/scala中创建一个文件,之后回到src目录下，进入sbt，开始compile,run,package

build.sbt文件中还可以定义很多东西，比如添加插件，声明额外的repository，声明各种编译参数等等，我们这里就不在一一赘述了。
project目录即相关文件介绍
project目录下的几个文件实际上都是非必须存在的，可以根据情况添加。
build.properties文件声明使用的要使用哪个版本的SBT来编译当前项目， 最新的sbt boot
launcher可以能够兼容编译所有0.10.x版本的SBT构建项目，比如如果我使用的是0.12版本的sbt，但却想用0.11.3版本的sbt来编译当前项目，则可以在build.properties文件中添加sbt.version=0.11.3来指定。
默认情况下，当前项目的构建采用使用的sbt boot launcher对应的版本。
plugins.sbt文件用来声明当前项目希望使用哪些插件来增强当前项目使用的sbt的功能，比如像assembly功能，清理ivy
local cache功能，都有相应的sbt插件供使用， 要使用这些插件只需要在plugins.sbt中声明即可，不用自己去再造轮子：


简单来说，在SBT中， 使用managed dependencies基本上就意味着往__libraryDependencies__这个Key中添加所需要的依赖，
添加的一般格式如下:
libraryDependencies += groupID % artifactID % revision
比如：
libraryDependencies += "org.apache.derby" % "derby" % "10.4.1.3"

如果有一堆依赖要添加，一行一行的添加是一种方式，其实也可以一次添加多个依赖：
libraryDependencies ++= Seq("org.apache.derby" %% "derby" % "10.4.1.3",              "org.scala-tools" %% "scala-stm" % "0.3",               ...)



	java -jar xxx.jar

## debug

用jdb来调试scala代码

[jdb](https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jdb.html)
[javap](https://docs.oracle.com/javase/8/docs/technotes/tools/unix/javap.html)

	# compile
	scalac -g:vars [source]

	# run and it should ouput a port
	env JAVA_OPTS="-agentlib:jdwp=transport=dt_socket,server=y,suspend=n" scala [class]

	# attach to the port
	jdb -attach [port]

	# disassembles class file to assist set breakpoints
	javap [class]



## plugin configure


all the plugins[community-plugins](http://www.scala-sbt.org/release/docs/Community-Plugins.html)


**assembly**

在project/assembly.sbt中添加

	addSbtPlugin("com.eed3si9n" % "sbt-assembly" % "0.14.3")

aassembly插件的目的是The goal is simple:Create a fat JAR of your project with all of its dependenies.

使用：

	$sbt assembly

详细链接[https://github.com/sbt/sbt-assembly](https://github.com/sbt/sbt-assembly)

**gen-idea**

用来生成idea的插件

在project/plugins.sbt中添加

	addSbtPlugin("com.github.mpeltonen" % "sbt-idea" % "1.6.0")


在工程中的build.sbt中添加

	ideaExcludeFolders += ".idea"

	ideaExcludeFolders += ".idea_modules"

详细链接[https://github.com/mpeltonen/sbt-idea](https://github.com/mpeltonen/sbt-idea)


**eclipse**

用于生成eclipse项目的插件

在project/plugins.sbt中添加

	addSbtPlugin("com.typesafe.sbteclipse" % "sbteclipse-plugin" % "2.4.0")


**scalastyle**

用来检查scala代码的规范

官网手册[http://www.scalastyle.org/sbt.html](http://www.scalastyle.org/sbt.html)





## jar

列表所有的class

	jar tf xxxx.jar | grep .class
