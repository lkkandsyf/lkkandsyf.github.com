---
layout: post
category : Mongodb
tagline: "Supporting tagline"
tags : []
---
{% include JB/setup %}

# Overview
{:.no_toc}

* dir
{:toc}

## Ubuntu install

下载软件包[tar.gz](https://docs.mongodb.com/manual/tutorial/install-mongodb-on-linux/)

```python
#mongodb download tarball  64bit
sudo mkdir /usr/local/mongodb
#add PATH to .bashrc
export PATH=/usr/local/mongodb/bin:$PATH
source ~/.bashrc
#run
cd
mkdir mongodb/data -p
#守护进程
mongod --dbpath=/home/lkk/mongodb/data/ --logpath=/home/lkk/mongodb/db.logs

#mongodb shell
sudo apt-get install mongodb-clients
#run
mongo
#help
help
db.help()

#python API
sudo pip install pymongo -i http://pypi.douban.com/simple --trusted-host pypi.douban.com
#指定版本
#sudo pip install pymongo=x.x.x -i http://pypi.douban.com/simple --trusted-host pypi.douban.com
ipython
import pymongo
#no error you can use happy
```

mongodb开机启动

```
vi /etc/re.local
#add
mongod -dbpath=DATAPATH --logpath=LOGPATH/db.logs --fork --smallfiles
```

[mongodb可视化工具](https://robomongo.org/)



[Python API](http://api.mongodb.com/python/)
[help web](http://xitongjiagoushi.blog.51cto.com/9975742/1657096)
[mongo shell](http://www.cnblogs.com/cswuyg/p/4595799.html)
[code](http://www.jianshu.com/p/5c4cd03d29ae)


xlrd 读取excel文件的库
[link](http://www.jb51.net/article/60510.htm)

## usage pymongo

**1.使用Python MongoDB驱动程序连接到MongoDB**

创建MongoClient,Database,Collection对象，并检索文档

```python
from pymongo import MongoClient
import pymongo

mongo		= MongoClient("localhost",27017)
db		= mongo['data_name']
collection	= db['collection_name']

print ("Number of Documents:")
print (collection.find().count())
```

**2.检索文档**

调用find\_one()时，将以`Dictiionary对象`的方式从服务器返回单个文档，然后就能在应用程序中使用这个对象

```python
doc = myColl.find_one()
```
Collection对象的方法find()返回一个`Cursor对象`，这个对象表示找到的文档，`但不取回它们`，可以多种不同的方式`迭代Cursor对象`

```python
cursor = myColl.find()
for doc in cursor:
	print (doc)
```
由于Python将游标视为`列表`，因此可以使用切片语法来获取游标的`部分内容`

```python
cursor = collection.find()
slice = cursor[5:10]
for doc in slice:
	print (doc)
```
使用函数来定义多个函数来输出一行或多行

```python
from pymongo import MongoClient

# print one doc
def getOne(collection):
	doc = collectin.find_one();
	print doc

# print many doc
def GetMany(collection):
	print ("\nMany using while loop:")
	cursor = collection.find()
	# define list store result
	res = []
	for doc in cursor:
		res.append(str(doc['attr')
		if len(res) > 10:
			break
	print (res)

# print many slice
def getManySlice(collection):
	print ("\nMany using for each loop:")
	cursor = collection.find()
	cursor = cursor[5:10]
	# define list store result
	res = []
	for doc in cursor:
		res.append(str(doc['attr')
	print (res)

# main fun
if __name__ == "__main__":
	mongo = MongoClient('localhost',27017)
	db = mongo['database_name']
	collection = db.[collection_name]
	getOne(collection)
	getMany(collection)
	getManySlice(collection)
```
一般情况，不会查询所有的文档，大部分都是限制性文档

查询运算符

```
运算符					描述
field:value		与字段值为value的文档匹配，例如:{name:"my_name"}
$gt			与字段值大于指定值的文档匹配，例如:{size:{$gt:5}}
$gte			与字段值大于指定值的文档匹配，例如:{size:{$gte:5}}
$in			与字段值包含在指定数组中的文档匹配，例如:{name:{$in:['item1','item2']}}
$lt			与字段值大于指定值的文档匹配，例如:{size:{$lt:5}}
$lte			与字段值大于指定值的文档匹配，例如:{size:{$lte:5}}
$ne			与字段值不等于指定的文档匹配，例如:{name:{$ne:"badName"}}
$nin			与字段值包含在指定数组中的文档匹配，例如:{name:{$nin:['item1','item2']}}
$or			使用逻辑或链接查询子句，并返回符合任何一个子句条件的文档，例如:{$or:[{size:{$lt:5}},{size:{$gt:10}}]}
$and			使用逻辑与链接查询子句，并返回与两个子句条件都匹配的文档，例如:{$and:[{size:{$lt:5}},{size:{$gt:10}}]}
$not			反转表达式的效果，返回与查询表达式不匹配的文档，例如:{$not:{size:{$lt:5}}}
$nor			使用逻辑或非链接查询子句，并反映两个子句都不匹配的文档，例如:{$nor:{size:{$lt:5},{name::"myname"}}}
$exists			匹配包含指定指定字段的文档，例如:{name:{$exists:true}}
$type			匹配指定的字段为指定的BSON类型的文档，例如:{specialFIeld:{$type:<BSONtype>}}
$mod			对字段进行求模运算，并返回结果为指定值的文档，求模运算条件是使用数组指定的，其中第一个数字是除数，第二个为余数，例如：{number:{$mod:[2,0]}}
$regex			返回指定字段的值与指定正则表达式匹配的文档，例如：{mySring:{$regex:'some.*exp'}}
$all			返回这样的文档，即其指定数组字段包含所有指定的元素，例如：{myArr:{$all:['one','two']}}
$elemMatch		返回这样的文档，即其指定数组字段至少有一个元素与指定的条件都匹配，例如：
$size			返回这样的文件，即其指定的数组字段为指定的长度，例如:{myarr:{$size:5}}
```

要创建一个查询对象来查找size=5的数据

```python
query = {'size':5}
myColl.find(query)
```
一个对象来查找size>5的数据

```python
query = {'size':
		{'$gt':5}}
myColl.find(query)
```
要查询一个对象来查找`第一个字母为x,y或z的数据`，可使用String数组

```python
query = {'first':
		{'$in':["x","y","z"]}}
myColl.find(query)
```
对多个条件的查询，组合在一块

```python
from pymongo import MongoClient

# show fun
def displayCursor(cursor):
	result = ''
	for doc in cursor:
		result += doc["word"] + ","
	if len(result) > 10:
		result = result[:65] + "..."
	print (result)

# 实现多个函数

# main fun
if __name__ == "__main__":
	mongo = MongoClient('localhost',27017)
	db = mongo['database_name']
	collection = db.[collection_name]
	# start call fun
```
在检索文档时，想先确定文档数，再决定是否检索。无论是在MongoDB服务器还是客户端，计算文档数的`开销`很小，因为不需要传输实际文档

```python
cursor = wordsColl.find()
itemCount = cursor.count()
```
用来统计文档的个数

```python
from pymongo import MongoClient

def countWords(collection):
	cursor = collection.find()
	print (cursor.count())

	query = {'first':'a'}
	cursor = collection.find(query)
	print (cursor.count())

# main fun
if __name__ == "__main__":
	mongo = MongoClient('localhost',27017)
	db = mongo['database_name']
	collection = db.[collection_name]
	countWords(collection)
```
**3.排序**

从MongoDB数据库检索文档时，一个重要的方面就是对文档进行`sort`,只想检索特定数量的文档或要对结果进行`分页`,这很有帮助，排序选项可以指定用于排序的文档字段和方向。

cursor对象的方法sort()能够指定要根据那些字段对游标的文件进行排序，并按照相应的顺序返回文档，方法sort()将一个`元组`((key,order)对)列表作为参数，其中key是要用于排序的字段名，而order为1(升序)或-1(降序)。

```python
sorter = [('name',1)]
cursor = myCollection.find()
cursor.sort(sorter)

# 多个字段排序
sorter = [('name',1),('value',-1)]
cursor = myCollection.find()
cursor.sort(sorter)

# the same to
sorter1 = [('name',1)]
sorter1 = [('value',-1)]
cursor = myCollection.find()
cursor = cursor.sort(sorter1)
cursor.sort(sorter2)

```
如何得到database对象的字段值----使用方法get(fieldName)

find\_one()返回的是一个`表示文档的Dictionary对象`

使用Python限制结果集，在大型系统上查询较复杂的文档时，常常需要限制返回的内容，以降低对服务器和客户端网络和内存的影响。要限制于查询匹配的结果集，方法有三:只接受一定数量的文档；限制返回的字段；对结果分页，分批的获取它们。

最简单的方法就是对find方法操作返回的Cursor对象调用方法limit()，它让cursor对象返回指定数量的文档。可避免检索的对象量超过应用程序的处理能力。

**4.大型数据进行分页**

```python
# 只显示前10个文档
cursor = collection.find()
cursor.limit(10)

for doc in cursor:
	print (doc)

##-----------------------------##
from pymongo import MongoClient

# show fun
def displayCursor(cursor):
	result = ''
	for doc in cursor:
		result += doc["word"] + ","
	if len(result) > 10:
		result = result[:65] + "..."
	print (result)

#def limitResults(collection,limit):
	query = {'first':'p'}
	cursor = collection.find(query)
	cursor.limit(limit)
	displayCursor(cursor)

# main fun
if __name__ == "__main__":
	mongo = MongoClient('localhost',27017)
	db = mongo['database_name']
	collection = db.[collection_name]
	limitResults(collection,1)
	limitResults(collection,5)
	limitResults(collection,10)
	limitResults(collection,20)
	limitResults(collection,30)
```
**5.限制从文档中返回的字段**

为限制文档检索时返回的数据量，另一种有效的方式就是限制要`返回的字段`。

```python
#要在返回的文档时排除字段stats,value,comments,可使用下面的field参数
fields = {'stats':false,'value',false,'comments',false}
cursor = myColl.find(None,fields)
#将查询的对象指定为None，因为要查所有的文档

#如果想返回first自段为t的文档的word和size字段
query = {'first':'t'}
fields = {'word':true,'size':True}
cursor = myColl.find(query,fields)

# 在find()使用参数fields来减少cursor对象表示的文档中的字段数
from pymongo import MongoClient

# show fun
def displayCursor(cursor):
	print (result)

# print include 字段
def includeFields(collection,fields):
	query = {'first':'p'}
	fieldObj = {}
	for field in fields:
		fieldObj[field] = True

	word = collection.find_one(query,fieldOb)
	displayCursor(word)

# print not include 字段
def execuldeFields(collection,fields):
	query = {'first':'p'}
	if not len(fields):
		fieldObj = Nonek
	else:
		fieldObj = {}
		for field in fields:
			fieldObj[field] = False

	doc = collection.find_one(query,fieldOb)
	displayCursor(doc)

# main fun
if __name__ == "__main__":
	mongo = MongoClient('localhost',27017)
	db = mongo['database_name']
	collection = db.[collection_name]
	excludeFields(collection,[])								#NULL
	excludeFields(collection,['letter','stats','charsets'])		#不包含这3个字段
	includeFields(collection,['word','size'])					#包含这两个字段
	includeFields(collection,['word','letter'])					#包含这两个字段
```

**6.生成文档不同字段值列表**

为了减少返回的文档数，一种常见的方法是分页。要进行分页，需要指定要在结果集中跳过的文档数，还需要限制返回的文档数。跳过的文档数将不断增加，每次的增量都是前一次返回的文档数。

要对一组文档进行分页，需要使用cursor对象的limit()和skip(),方法skip()能够指定在返回文档前要跳过多少个文档，每次获取下一组文档时，都增大skip()中指定的值，增量为前一次调用limit()时指定的的值，这样就实现的数据集分页。

下面的语句查找第11~20个文档

```python
cursor = collection.find()
cursor = limit(10)
cursor.skip(10)
```
进行分页时，务必调用`sort方法`来确保文档的排列顺序不变。

```python
from pymongo import MongoClient

# show fun
def displayCursor(cursor):
	result = ''
	for doc in cursor:
		result += doc["word"] + ","
	if len(result) > 65:
		result = result[:65] + "..."
	print (result)

# pages
def pageResults(collection,skip):
	query = {'first':'w'}
	cursor = collection.find()
	cursor.limit(10)
	cursor.skip(skip)
	print ("page" + str(skip+1) + "to" + str(skip+cursor.count(True)) + ":")
	displayCursor(cursor)
	if (cursor.count(True) == 10):
		pageResults(collection.skip+10)

# main fun
if __name__ == "__main__":
	mongo = MongoClient('localhost',27017)
	db = mongo['database_name']
	collection = db.[collection_name]
	pageResults(collection.0)
```
获取一组文档中某个字段的`不同值列表`，不同的distinct意味着即使有上千文档，只想知道那些独一无二的。

collection和cursor对象的方法distinct()能够找出字段的不同值列表，distinct(key),key是一个字符串，指定了要获取哪个字段的不同值。要获取子文档中字段的不同值，可以使用句点语法，如stats.count.如果要获取部分文档中指定字段的不同值，可先用查询生成一个cursor对象，再对这个对象cursor对象调用方法distinct()

```python
query = {'age':{'$gt':65}}
cursor = myColl.find(query)
lastNames = cursor.distinct('last')
```
方法distinct()返回一个数组，其中包含指定字段的不同的，例如：["smith","liang",.....]

```python
# 使用Python检索一组文档中指定字段的不同值
from pymongo import MongoClient

def sizesOfAllWords(collection):
	results = collection.distinct("size")
	print ("\nDistinct Sizes of words:")
	print (str(results))

def sizeOfQWords(collection):
	query = {'first':'q'}
	cursor = collection.find(query)
	results = cursor.distinct("size")
	print ("\n Distinct Sizes of words starting with Q:")
	print (str(results))

def firstLetterOfLongWords(collection):
	query = {'size':{'gt':12}}
	cursor = collection.find(query)
	results = cursor.distinct("first")
	print ("\n Distinct first letters of words longer than" + "12 characters:")
	print (str(results))

# main fun
if __name__ == "__main__":
	mongo = MongoClient('localhost',27017)
	db = mongo['database_name']
	collection = db.[collection_name]
	sizesOfAllWords(collection)
	sizesOfWords(collection)
	firstLetterOfLongWords(collection)
```

**7.对文档进行分组并生成返回数据集**

在Python中对大型数据集执行操作时，根据文档的一个或多个字段的值将结果`分组`通常很有用，要将结果分组，可使用collection对象的方法group()。分组请求首先收集所有与查询匹配的文档。再对于指定键的每个不同的值，都在数组中添加一个分组对象，对这些分组对象进行操作，并返回这个分组对象数组。

方法group()的语法如下：group({key,cond,initial,reduce,[finalize]}),其中key,cond,initial都是Dictionary对象，指定了要用来分组的字段，查询以及要使用的初始文档；参数reduce和finalize为String对象，包含以字符串的方式表示的JavaScript函数，这些函数将在服务器上运行以归并文档并生成最终的结果。

```python
#简单分组，创建了对象key,cond,initial,并以字符串的方式传入一个reduce函数
key = {'first':True}
cond = {'first':'a','size':5}
initial = {'count':0}
reduce = "function (obj,prev){prev.count++}"
results = collection.group(key,cond,initial,reduce)
#方法group()返回一个包含分组结果的List，
for result in results:
	print (result)

#使用Python根据键值将文档分组,使用collection对象的方法group()从数据库中检索文档，根据指定字段进行分组，并
#在服务器上执行reduce和finalize函数。

from pymongo import MongoClient
def displayGroup(results):
	for result in results:
		print (result)

#将第一个字母为a且最后一个为元字母的单词分组
def firstIsALastIsVowel(collection):
	key = {'first':True,"last":True}
	cond = {'fist':'a','last':{
					'$in':["a","e","i","o",,"u"]
			}}
	initial = {'count':0}
	reduce = "functin (obj,prev) {pre.count++}"
	results = collection.group(key,cond,initial,reduce)
	print ("\n 'A' words grouped be first and last"+"letter that end with a vowel:")
	displayGroup(results)

# main fun
if __name__ == "__main__":
	mongo = MongoClient('localhost',27017)
	db = mongo['database_name']
	collection = db.[collection_name]
	firstIsALastIsVowel(collection)
```

**8.使用聚合流水线根据集合中的文档生成数据集**

另一个很有用的工具是聚合`框架`，collection对象提供了对数据执行聚合操作的方法aggregate(),这个方法：appregate(operator,[operator,...])
参数operator是一系列运算符对象，提供了用于聚合数据的流水线。这些运算符对象是使用聚合运算创建的Dictionary对象。

下面的代码定义了运算符$group和%limit,其中运算符$group根据字段word进行分组(并将该字段的值存储在结果文档的\_id字段中),使用$avg计算size字段的平均值(并将结果存储在average字段中)。`请注意`,在聚合运算中引用原始文档的字段时，`必须在字段的前面加上$`

```python
group = {'$group':
	{
		'_id':$word,
		'average':{'$avg':'$size'}
	}}
limit = {'limit':10}
result = collection.aggregate([group,limit])
```
方法aggregate()返回一个Dictionary对象。这个Dictionary对象包含一个result键，而该键对应的值是一个包含聚合结果的列表

```python
from pymongo import MongoClient

def displayAggregate(results):
	for result in results['result']:
		print (result)

#使用一条包含运算符$match,$group,$sort的聚合流水线，这条流水线查找以元音字母开头的单词，根据第一个字母将这些单词分组，并找出各组中最长的最短单词的长度
def largeSmallVowels(collection):
	match = {'match':
				{'first':
					{
						'$in':['a','e','i','o','u']
					}
				}
			}
	group = {'$group':
					{'_id':'first',
						'largest':{'$max':$size},
						'smallest':{'$min':$size},
						'total':{'$sum':1}
					}
			}
	sort = {'$sort':{'first':1}}
	result  = collection.aggregate([match,group,sort])
	print ("\n Largest and smallest word size for" + "words begining with a vowel")
	displayAggregate(result)

#使用了一条包含运算符$group,$sort,$limit的聚合流水线，根据第一个字母将单词分组，并找出单词平均长度最长的前5组
def top5AverageWordFirst(collection):
	group = {'$group':
				{'_id':'first',
				'average':{'$avg':'$size'}
				}
			}
	sort = {'$sort':{'$average':-1}}
	limit = {'limit':5}
	result = collection.aggregate([group,sort,limit])
	print ("\n First letter of top 5 largest average" + "word size:")
	displayAggregate(result)

# main fun
if __name__ == "__main__":
	mongo = MongoClient('localhost',27017)
	db = mongo['database_name']
	collection = db.[collection_name]
	largeSmallVowels(collection)
	top5AverageWordFirst(collection)
```

**9.插入，删除，获取修改保存，更新，upsert操作**

在Python应用程序中，使用添加，操作，删除文档，修改文档集合中数据的方式：插入新文档，通过更新或保存修改既有文档以及执行upsert操作(先尝试更新文档，如果没有找到，就插入一个新文档)

**10.**




