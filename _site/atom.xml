<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>Yitao's Blog</title>
 <link href="" rel="self"/>
 <link href=""/>
 <updated>2017-04-10T05:37:17+00:00</updated>
 <id></id>
 <author>
   <name>yitao</name>
   <email>simpleyyt@gmail.com</email>
 </author>

 
 <entry>
   <title>Hello World 的编译链接概述</title>
   <link href="/2017/02/12/helloworld-compile-and-link"/>
   <updated>2017-02-12T00:00:00+00:00</updated>
   <id>/2017/02/12/helloworld-compile-and-link</id>
   <content type="html">&lt;p&gt;《程序员的自我修养》读书笔记，简单概述一个 Hello World 程序的编译链接过程。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;有如下的&lt;code&gt;hello.c&lt;/code&gt;源文件：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Hello World&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以用 GCC 来编译运行：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span class=&quot;nv&quot;&gt;$gcc&lt;/span&gt; hello.c
&lt;span class=&quot;nv&quot;&gt;$.&lt;/span&gt;/a.out
Hello World
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上述步骤可以分解为 4 个步骤，分别是**预处理（Prepressing）**、**编译（Compilation）**、**汇编（Assembly）**和**链接（Linking）**。&lt;/p&gt;

&lt;h2 id=&quot;toc_0&quot;&gt;被隐藏了的过程&lt;/h2&gt;

&lt;h3 id=&quot;toc_1&quot;&gt;预处理&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span class=&quot;nv&quot;&gt;$gcc&lt;/span&gt; -E hello.c -o hello.i
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或者：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span class=&quot;nv&quot;&gt;$cpp&lt;/span&gt; hello.c &amp;gt; hello.i
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;预编译过程主要处理那些源代码文件听以“#”开始的预编译指令。&lt;/p&gt;

&lt;p&gt;经过预编译后的 .i 文件不包含任何宏定义，因为所有的宏已经被展开，并且包含的文件也已经被插入到 .i 文件中。&lt;/p&gt;

&lt;h3 id=&quot;toc_2&quot;&gt;编译&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span class=&quot;nv&quot;&gt;$gcc&lt;/span&gt; -S hello.i -o hello.S
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或者使用&lt;code&gt;cc1&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span class=&quot;nv&quot;&gt;$/&lt;/span&gt;usr/lib/gcc/i486-linux-gnu/4.1/cc1 hello.c
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;编译过程就是把预处理完的文件进行一系列**词法分析**、**语法分析**、**语义分析**及**优化**后产生的相应的汇编代码文件。&lt;/p&gt;

&lt;p&gt;实际上 gcc 这个命令只是这些后台程序的包装，它会根据不同的参数要求去调用预编译编译程序 cc1、汇编器 as、链接器 ld。&lt;/p&gt;

&lt;h3 id=&quot;toc_3&quot;&gt;汇编&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span class=&quot;nv&quot;&gt;$as&lt;/span&gt; hello.s -o hello.c
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或者：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span class=&quot;nv&quot;&gt;$gcc&lt;/span&gt; -c hello.s -o hello.o
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;汇编器是将汇编代码转变成机器可以执行的指令，每一个汇编语句几乎都对应一条机器指令。&lt;/p&gt;

&lt;h3 id=&quot;toc_4&quot;&gt;链接&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span class=&quot;nv&quot;&gt;$ld&lt;/span&gt; -static crt1.o crti.o crtbeginT.o hello.o -start-group -lgcc -lgcc_eh -lc -end-group crtend. crtn.o
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;toc_5&quot;&gt;编译器做了什么&lt;/h2&gt;

&lt;p&gt;编译过程一般可以分为6步：扫描、语法分析、语义分析、源代码优化、代码生成和目标代码优化。&lt;/p&gt;

&lt;p&gt;以如下代码为例：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;toc_6&quot;&gt;词法分析&lt;/h3&gt;

&lt;p&gt;源代码被输入到**扫描器（Scanner）**，进行词法分析，生成一系列的**记号（Token）**。&lt;/p&gt;

&lt;table&gt;&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;记号&lt;/th&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;array&lt;/td&gt;
&lt;td&gt;标识符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[&lt;/td&gt;
&lt;td&gt;左方括号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;index&lt;/td&gt;
&lt;td&gt;标识符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;]&lt;/td&gt;
&lt;td&gt;右方括号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;=&lt;/td&gt;
&lt;td&gt;赋值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;(&lt;/td&gt;
&lt;td&gt;左圆括号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;index&lt;/td&gt;
&lt;td&gt;标识符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;加号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;数字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;)&lt;/td&gt;
&lt;td&gt;右圆括号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;乘号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;(&lt;/td&gt;
&lt;td&gt;左圆括号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;数字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;加号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;数字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;)&lt;/td&gt;
&lt;td&gt;右圆括号&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;在识别记号的同时，扫描器也将标识符存放到符号表，将数字、字符串常量存放到文字表等。&lt;/p&gt;

&lt;p&gt;有一个叫 lex 的程序可以实现词法分析，它会按照用户之前描述好的词法规则将输入的字符串分割成一个个记号。&lt;/p&gt;

&lt;h3 id=&quot;toc_7&quot;&gt;语法分析&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;语法分析器（Grammar Parser）&lt;/strong&gt;将上述产生的记号进行语法分析，从而生成**语法树（Syntax Tree）**。&lt;/p&gt;

&lt;p&gt;有一个现在的工具叫 yacc（Yet Another Compiler Compiler）可以构建出语法树。&lt;/p&gt;

&lt;h3 id=&quot;toc_8&quot;&gt;语义分析&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;语义分析器（Semantic Analyzer）&lt;/strong&gt;完成了对表达式的语法层面的分析，即**静态语义（Static Semantic）**，包括声明和类型匹配，类型的转换。&lt;/p&gt;

&lt;p&gt;语义分析阶段后，语法树的表达式都被标识了类型，如有隐式转换，则插入相应的转换节点。&lt;/p&gt;

&lt;h3 id=&quot;toc_9&quot;&gt;中间语言的生成&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;源码优化器（Source Code Optimizer）&lt;/strong&gt;将整个语法树转换成**中间代码（Intermediate Code）**，常见的有**三地址码（Three-address Code）**和**P-代码（P-Code）**，再进行源码级别的优化。&lt;/p&gt;

&lt;p&gt;中间代码使用编译器可以被分为前端和后端。编译器前端负责产生机器无关的中间代码，编译器后端将中间代码转换成目标机器代码。&lt;/p&gt;

&lt;h3 id=&quot;toc_10&quot;&gt;目标代码生成与优化&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;代码生成（Code Generator）&lt;/strong&gt;将中间代码转换成目标机器代码，**目标代码化化器（Target Code Optimizer）**则对目标代码进行优化。&lt;/p&gt;

&lt;h2 id=&quot;toc_11&quot;&gt;静态链接&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;链接（Linking）&lt;/strong&gt;的主要内容就是把各个模块之间相互引用的部分都处理好。&lt;/p&gt;

&lt;p&gt;链接过程主要包括了**地址和空间分配（Address and Storage Allocation）**、**符号决议（Symbol Resolution）**和**重定位（Relocation）**这些步骤。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>彩虹表原理</title>
   <link href="/2016/12/24/how-rainbow-table-work"/>
   <updated>2016-12-24T00:00:00+00:00</updated>
   <id>/2016/12/24/how-rainbow-table-work</id>
   <content type="html">&lt;p&gt;以前一直以为彩虹表就是一个大的数据库，破解的时候直接通过查表获得明文。今天发现我错了，彩虹表的原理还是挺有趣的。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;如果直接暴力破解 Hash 的明文太费时，如果通过查表的方法则太耗存储。彩虹表则是暴力破解与查表破解的折中。&lt;/p&gt;

&lt;h2 id=&quot;toc_0&quot;&gt;原理&lt;/h2&gt;

&lt;p&gt;假设有这么一个函数&lt;code&gt;R&lt;/code&gt;，可以将 Hash 值转化与字符串（非明文，而是另一个字符串），称其为衰减函数。假设&lt;code&gt;p&lt;/code&gt;为明文，&lt;code&gt;h&lt;/code&gt;为明文的 Hash 值，&lt;code&gt;H&lt;/code&gt;为 Hash 函数。彩虹表在建表时，先选一个&lt;code&gt;p[0]&lt;/code&gt;，做如下计算：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;h[0] = H(p[0])
p[1] = R(h[0])
h[1] = H(p[1])
...
h[k]  = H(p[k])
...
h[n - 1] = H(p[n - 1])
p[n] = R(h[n - 1])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;其中&lt;code&gt;n&lt;/code&gt;为迭代的次数。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;经过，这种运算之后，会形成一条 Hash 链：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;p[0]---&amp;gt;h[0]---&amp;gt;p[1]---&amp;gt;...---&amp;gt;p[k]---&amp;gt;h[k]---&amp;gt;...---&amp;gt;p[n]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这条链上已经有&lt;code&gt;n&lt;/code&gt;对明文到 Hash 值的对应关系了，但我们只保存首尾&lt;code&gt;p[0]&lt;/code&gt;和&lt;code&gt;p[n]&lt;/code&gt;，因为中间的值可以用&lt;code&gt;p[0]&lt;/code&gt;重新通过上述的计算运算出来。&lt;/p&gt;

&lt;p&gt;彩虹表中有好多条这样的链&lt;code&gt;p[0]--&gt;p[n]&lt;/code&gt;，&lt;code&gt;n&lt;/code&gt;值取足够大。这样就可以用&lt;code&gt;p[0]&lt;/code&gt;和&lt;code&gt;p[n]&lt;/code&gt;的存储空间，存储&lt;code&gt;n&lt;/code&gt;对的明文到 Hash 值的对应关系。&lt;/p&gt;

&lt;h2 id=&quot;toc_1&quot;&gt;破解&lt;/h2&gt;

&lt;p&gt;假设待破解的 Hash 值为&lt;code&gt;h&amp;#39;&lt;/code&gt;，那么我们可以反复地迭代运算 &lt;code&gt;p&amp;#39; = R(h&amp;#39;), h‘= H(p&amp;#39;)&lt;/code&gt;，直到&lt;code&gt;p&amp;#39;&lt;/code&gt;与彩虹表中的某个&lt;code&gt;p[n]&lt;/code&gt;相等。&lt;/p&gt;

&lt;p&gt;该链为&lt;code&gt;p[0]--&gt;p[n]&lt;/code&gt;，那么&lt;code&gt;h&amp;#39;&lt;/code&gt;的明文很有可能在这条链中，因为这条链是通过&lt;code&gt;p[0]&lt;/code&gt;反复迭代得到&lt;code&gt;p[n]&lt;/code&gt;的，&lt;code&gt;h&amp;#39;&lt;/code&gt;也是通过反复迭代得到&lt;code&gt;p[n]&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;我们只要知道&lt;code&gt;h&amp;#39;&lt;/code&gt;迭代到&lt;code&gt;p[n]&lt;/code&gt;的次数，只在找到链中迭代到&lt;code&gt;p[n]&lt;/code&gt;相同次数的&lt;code&gt;h[k]&lt;/code&gt;，就可以获得其明文&lt;code&gt;p[k]&lt;/code&gt;（在链中，&lt;code&gt;h[k] = H(p[k])&lt;/code&gt;）。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>支付宝 AR 红包破解</title>
   <link href="/2016/12/21/alipay-ar-rb-crack"/>
   <updated>2016-12-21T00:00:00+00:00</updated>
   <id>/2016/12/21/alipay-ar-rb-crack</id>
   <content type="html">&lt;p&gt;网上有好多支付宝的 AR 红包的破解方法，试了一下都不尽人意，所以自己撸了一下简单的。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;破解的想法非常简单：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;遍历每一行，求 RGB 值的方差。&lt;/li&gt;
&lt;li&gt;如果方差小于某个阈值则该行为小横条，用上面几行替换。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;网上还有好多其他的方法，比如先手工获得小横条位置、识别小横条的灰色，我就不折腾了。&lt;/p&gt;

&lt;p&gt;最后的效果没有那么好，有些识别不出来，亮色点的图片识别率会高一点。我识别出了周围的4个红包，还是挺麻烦的，玩玩就好。&lt;/p&gt;

&lt;p&gt;代码如下：&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/02683accd59e309d574e9b499edafc7d.js&quot;&gt; &lt;/script&gt;
</content>
 </entry>
 
 <entry>
   <title>C++ 函数重载与函数匹配</title>
   <link href="/2016/12/17/function-overload-and-match"/>
   <updated>2016-12-17T00:00:00+00:00</updated>
   <id>/2016/12/17/function-overload-and-match</id>
   <content type="html">&lt;p&gt;《C++ Primer》笔记，整理关于函数重载与函数匹配的笔记。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;toc_0&quot;&gt;函数重载&lt;/h2&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//原函数
&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//正确：形参类型不同
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 正确：形参个数不同
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//错误：只有返回类型不同
&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;int32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;int32&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//与原函数等价：形参类型相同
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//与原函数等价：顶层 const 将被忽略
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//与原函数等价：只是省略了形参名字
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;函数重载有如下的规则：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;名字相同，形参类型不一样。&lt;/li&gt;
&lt;li&gt;不允许两个函数除了返回类型外其他所有的要素都相同。&lt;/li&gt;
&lt;li&gt;顶层&lt;code&gt;const&lt;/code&gt;的形参无法和没有顶层&lt;code&gt;const&lt;/code&gt;的形参区分。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其中返回类型不同时编译时会出错，而类型别名、项层&lt;code&gt;const&lt;/code&gt;、省略形参名字只是重复声明而已，只要不定义，编译就不会出错，比如：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;c1&quot;&gt;//只定义了其中一个
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;toc_1&quot;&gt;函数匹配&lt;/h2&gt;

&lt;h3 id=&quot;toc_2&quot;&gt;名字查找&lt;/h3&gt;

&lt;p&gt;函数匹配的第一步便是**名字查找（name lookup）**，确定**候选函数**。&lt;/p&gt;

&lt;p&gt;名字查找有两方面：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;常规查找（normal lookup）&lt;/li&gt;
&lt;li&gt;实参决定的查找（argument-dependent lookup，ADL）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所有函数调用都会进行常规查找，只有函数的实参包括类类型对象或指向类类型对象的指针/引用的时候，才会进行实参决定的查找。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;常规查找&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;//1
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//作用域
&lt;/span&gt;    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;//2
&lt;/span&gt;    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;//3
&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;test1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//候选函数为函数2和3
&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;test2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//将函数1加入当前作用域
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//候选函数为函数1
&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从函数被调用的局部作用域开始，逐渐向上层寻找被调用的名字，一旦找到就停止向上寻找，将找到的所有名字加入候选函数。&lt;/p&gt;

&lt;p&gt;此外，using语句可以将其他作用域的名字引用到当前作用域。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ADL查找&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//1
//第一个实参所在命名空间
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Name1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;friend&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//2
&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//3
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//第二个实参的间接父类所在命名空间
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Name00&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;T00&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;friend&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//4
&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//5
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//第二个实参父类所在命名空间
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Name0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;T0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Name00&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T00&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;friend&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//6
&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//7
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//第二个实参所在命名空间
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Name2&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Name0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;friend&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//8
&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//9
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Name1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Name2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//9个函数全是候选函数  
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;//第1个函数是normal lookup找到的
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;//后8个函数全是argument-dependent lookup找到的
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从第一个类类型参数开始，依次遍历所有类类型参数。对于每一个参数，进入其类型定义所在的作用域（类内友元函数也包括在内），并依次进入其基类、间接基类……定义所在的作用域，查找同名函数，并加入候选函数。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;在继承体系中上升的过程中，不会因为找到同名函数就停止上升，这不同于常规查找。&lt;/p&gt;

&lt;p&gt;类中的运算符重载也遵循 ADL 查找，其候选函数集既包括成员函数，也应该包括非成员函数。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;A&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;operator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//1
&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;operator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//2
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;operator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//3
&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//1、2、3都是候选函数
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;toc_3&quot;&gt;确定可行函数&lt;/h3&gt;

&lt;p&gt;第二步便是从候选函数中选出可行函数，选择的标准如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;形参数量与本次调用提供的实参数量相等&lt;/li&gt;
&lt;li&gt;每个实参的类型与对应的形参类型相同，或者能转换成形参类型&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;c1&quot;&gt;//以下为候选函数
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//可行函数
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//可行函数：实参可转化成形参类型
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//可行函数
&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//非可行函数：形参数量不匹配
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//非可行函数：实参不能转换成形参
&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;toc_4&quot;&gt;寻找最佳匹配&lt;/h3&gt;

&lt;p&gt;从可行函数中选择最匹配的函数，如果有多个形参，则最佳匹配条件为：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;该函数每个实参的匹配都不劣于其他可行函数需要的匹配。&lt;/li&gt;
&lt;li&gt;至少有一个实参的匹配优于其他可行函数提供的匹配。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;否则，发生二义性调用错误。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;c1&quot;&gt;//可行函数
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//二义性错误：double 向 int 的转换与向 float 的转换一样好
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//调用 void func(int a, int b)
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为了确定最佳匹配，实参类型到形参类型的转换等级如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;精确匹配：

&lt;ul&gt;
&lt;li&gt;实参类型和形参类型相同。&lt;/li&gt;
&lt;li&gt;实参从数组类型或函数类型转换成对应的指针类型。&lt;/li&gt;
&lt;li&gt;向实参添加顶层&lt;code&gt;const&lt;/code&gt;或者从实参中删除顶层&lt;code&gt;const&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;通过&lt;code&gt;const&lt;/code&gt;转换实现的匹配。&lt;/li&gt;
&lt;li&gt;通过类型提升实现的匹配。&lt;/li&gt;
&lt;li&gt;通过算术类型转换或指针转换实现的匹配。&lt;/li&gt;
&lt;li&gt;通过类类型转换实现的匹配。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;em&gt;一般不会存在这个阶段不会同时存在两个以上的精确匹配，因为两个精确的匹配在本质上是等价的，在定义重载函数时，编译器可能就报出重定义的错误了。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;挑几个重点的来详细说一下。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;指针转换实现的匹配&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;0 或&lt;code&gt;nullptr&lt;/code&gt;能转换成任意指针类型。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;T *&lt;/code&gt; 能转换成 &lt;code&gt;void *&lt;/code&gt;，&lt;code&gt;const void *&lt;/code&gt;转换成&lt;code&gt;const void*&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;派生类向基类类型的转换。&lt;/li&gt;
&lt;li&gt;函数与函数指针的形参类型必须精确匹配。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;类类型转换实现的匹配&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;两个类型提供相同的类型转换将产生二义性问题。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;//把一个 B 转换成 A
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;B&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;operator&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 也是把一个 B 转换成 A
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;B&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//二义性错误：f(B::operator A()) 还是 f(A::A(const B&amp;amp;))
&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;operator&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//正确：使用 B 的类型转换运算
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//正确：使用 A 的构造函数
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;类当中定义了多个参数都是算术类型的构造函数或类型转换运算符，也会产生二义性问题。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;operator&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;operator&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//二义性错误：f(A::operator int()) 还是 f(A::operator double())？
&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//二义性错误：A::A(int) 还是 A::A(double)？
&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;short&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//正确：使用 A::A(int)
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当我们使用两个用户定义的类型转换时，如果转换函数之前或之后存在标准类型转换，则标准类型转换将决定最佳匹配到底是哪个。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>C++ 函数匹配及实参推断</title>
   <link href="/2016/11/21/function-matching-and-argument-deduction"/>
   <updated>2016-11-21T00:00:00+00:00</updated>
   <id>/2016/11/21/function-matching-and-argument-deduction</id>
   <content type="html">&lt;p&gt;记录一下函数重载、函数匹配、名字查找与实参类型推断的规则。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;toc_0&quot;&gt;函数重载&lt;/h2&gt;

&lt;h3 id=&quot;toc_1&quot;&gt;函数重载规则&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;名字相同，形参类型不一样。&lt;/li&gt;
&lt;li&gt;不允许两个函数除了返回类型外其他所有的要素都相同。&lt;/li&gt;
&lt;li&gt;顶层&lt;code&gt;const&lt;/code&gt;的形参无法和没有顶层&lt;code&gt;const&lt;/code&gt;的形参区分。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;toc_2&quot;&gt;重载与作用域&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;内层作用域中声明的名字，将隐藏外层作用域中声明的同名实体。&lt;/li&gt;
&lt;li&gt;名字查找发生在类型检查之前。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;toc_3&quot;&gt;名字查找&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;首先，在名字所在的块中寻找其声明语句，只考虑在名字使用之前出现的声明。&lt;/li&gt;
&lt;li&gt;如果没有找到，继续查找外层作用域。&lt;/li&gt;
&lt;li&gt;如果最终没有找到匹配的声明，则程序报错。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对于类的定义：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;首先，编译成员的声明。&lt;/li&gt;
&lt;li&gt;直到类全部可见后才编译函数体。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;toc_4&quot;&gt;函数匹配&lt;/h2&gt;

&lt;h3 id=&quot;toc_5&quot;&gt;函数匹配步骤&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;确定候选函数和可行函数&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;选择函数名相同的、声明在调用点可见的函数作用候选函数。&lt;br&gt;
在候选函数中选出形参数量匹配并且类型可转换的函数作用可行函数。&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;寻找最佳匹配&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;从可行函数中选择最匹配的函数，如果有多个形参，则最佳匹配条件为：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;该函数每个实参的匹配都不劣于其他可行函数需要的匹配。&lt;/li&gt;
&lt;li&gt;至少有一个实参的匹配优于其他可行函数提供的匹配。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;否则，发生二义性调用错误。&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;toc_6&quot;&gt;实参类型转换等级&lt;/h2&gt;

&lt;p&gt;具体排序如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;精确匹配：

&lt;ul&gt;
&lt;li&gt;实参类型和形参类型相同。&lt;/li&gt;
&lt;li&gt;实参从数组类型或函数类型转换成对应的指针类型。&lt;/li&gt;
&lt;li&gt;向实参添加顶层&lt;code&gt;const&lt;/code&gt;或者从实参中删除顶层&lt;code&gt;const&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;通过&lt;code&gt;const&lt;/code&gt;转换实现的匹配。&lt;/li&gt;
&lt;li&gt;通过类型提升实现的匹配。&lt;/li&gt;
&lt;li&gt;通过算术类型转换或指针转换实现的匹配。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;toc_7&quot;&gt;函数指针&lt;/h2&gt;

&lt;p&gt;函数与函数指针的形参类型必须精确匹配。&lt;/p&gt;

&lt;h2 id=&quot;toc_8&quot;&gt;类类型转换运算符匹配&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;如果类类型和目标类型之间存在多种转换的方式，则可能发生二义性错误：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;两个类型提供相同的类型转换。&lt;/li&gt;
&lt;li&gt;类定义了多个转换的规则。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当我们使用两个用户定义的类型转换时，如果转换函数之前或之后存在标准类型转换，则标准类型转换将决定最佳匹配到底是哪个。&lt;/p&gt;

&lt;h2 id=&quot;toc_9&quot;&gt;重载函数与转换构造函数&lt;/h2&gt;

&lt;p&gt;如果两个或多个类型转换都提供了同一种可行的匹配，则这些类型转换一样好。&lt;/p&gt;

&lt;p&gt;在调用重载函数时，如果需要额外的标准类型转换，则该转换的级别只有当所有可行函数请求同一个用户定义的类型转换时才有用。如果所需的用户定义的类型转换不止一个，则该调用具有二义性。&lt;/p&gt;

&lt;h2 id=&quot;toc_10&quot;&gt;函数匹配与重载运算符&lt;/h2&gt;

&lt;p&gt;表达式中运算符的候选函数集既包括成员函数，也应该包括非成员函数。&lt;/p&gt;

&lt;h2 id=&quot;toc_11&quot;&gt;模板实参推断&lt;/h2&gt;

&lt;h3 id=&quot;toc_12&quot;&gt;类型转换与模板类型参数&lt;/h3&gt;

&lt;p&gt;能应用于函数模板的类型转换：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;顶层 const 会被忽略。&lt;/li&gt;
&lt;li&gt;const 转换：非 const 对象的引用（或指针）传递给一个 const 的引用（或指针）的形参。&lt;/li&gt;
&lt;li&gt;数组或函数指针的转换。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一个模板类型参数可以用作多个函数形参的类型。由于只允许有限的几种类型转换，因此传递给这些形参的实参必须具有相同的类型。&lt;/p&gt;

&lt;p&gt;正常类型转换应用于显示指定的实参。&lt;/p&gt;

&lt;h3 id=&quot;toc_13&quot;&gt;函数指针和实参推断&lt;/h3&gt;

&lt;p&gt;当参数是一个函数模板实例的地址时，程序上下文必须満足：对每个模板参数，能唯一确定其类型或值。&lt;/p&gt;

&lt;h3 id=&quot;toc_14&quot;&gt;重载与模板&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;对于一个调用，其候选函数包括所有模板实参推断成功的函数模板实例。&lt;/li&gt;
&lt;li&gt;候选的函数模板总是可行的，因为模板实参推断会排除任何不可行的模板。&lt;/li&gt;
&lt;li&gt;可行函数按类型转换来排序，如果有一个函数比其他函数匹配更好，则选择此函数。&lt;/li&gt;
&lt;li&gt;如果有多个函数提供同样好的匹配则：

&lt;ul&gt;
&lt;li&gt;如果同样好的函数中 且个是非模板函数，则选择此函数。&lt;/li&gt;
&lt;li&gt;如果没有非模板函数，如果其中一个模板函数更特例化，则选择此模板。&lt;/li&gt;
&lt;li&gt;否则，此调用有歧义。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;toc_15&quot;&gt;异常类型与 catch 类型的匹配&lt;/h2&gt;

&lt;p&gt;异常类型与&lt;code&gt;catch&lt;/code&gt;类型必须精确匹配：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;允许从非常量向常量转换。&lt;/li&gt;
&lt;li&gt;允许从派生类向基类转换。&lt;/li&gt;
&lt;li&gt;数组与函数转换成指针。&lt;/li&gt;
&lt;/ul&gt;
</content>
 </entry>
 
 <entry>
   <title>C++ 字面值常量</title>
   <link href="/2016/11/14/cpp-literal"/>
   <updated>2016-11-14T00:00:00+00:00</updated>
   <id>/2016/11/14/cpp-literal</id>
   <content type="html">&lt;p&gt;在类型转换和函数匹配中，字面值类型也是非常值得关注的。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;toc_0&quot;&gt;整型和浮点型字面值&lt;/h2&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* 十进制 */&lt;/span&gt;  &lt;span class=&quot;mo&quot;&gt;024&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* 八进制 */&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x14&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* 十六进制 */&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;默认情况下，十进制字面值是带符号数，八进制和十六进制既可能是带符号的也可能是无符号的。&lt;/p&gt;

&lt;p&gt;十进制字面值类型是&lt;code&gt;int&lt;/code&gt;、&lt;code&gt;long&lt;/code&gt;和&lt;code&gt;long long&lt;/code&gt;中尺寸最小的。&lt;/p&gt;

&lt;p&gt;八进制和十六进制字面值类型是&lt;code&gt;int&lt;/code&gt;、&lt;code&gt;unsigned int&lt;/code&gt;、&lt;code&gt;long&lt;/code&gt;、&lt;code&gt;unsigned long&lt;/code&gt;、&lt;code&gt;long long&lt;/code&gt;和&lt;code&gt;unsigned long long&lt;/code&gt;中的尺寸最小者。&lt;/p&gt;

&lt;p&gt;严格来说，十进制字面值不会是负数，负数只是对字面值取负值而已。&lt;/p&gt;

&lt;p&gt;默认的，浮点型字面值是一个&lt;code&gt;double&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&quot;toc_1&quot;&gt;转义序列&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;\x&lt;/code&gt;后紧跟1个或多个十六进制数字，或&lt;code&gt;\&lt;/code&gt;后紧跟1个、2个或3个八进制数字。&lt;/p&gt;

&lt;h2 id=&quot;toc_2&quot;&gt;指定字面值的类型&lt;/h2&gt;

&lt;table&gt;&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;前缀&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;u&lt;/td&gt;
&lt;td&gt;Unicode 16 字符&lt;/td&gt;
&lt;td&gt;char16_t&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;U&lt;/td&gt;
&lt;td&gt;Unicode 32 字符&lt;/td&gt;
&lt;td&gt;char32_t&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;L&lt;/td&gt;
&lt;td&gt;宽字符&lt;/td&gt;
&lt;td&gt;wchar_t&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;u8&lt;/td&gt;
&lt;td&gt;UTF-8（仅用于字符串字面常量）&lt;/td&gt;
&lt;td&gt;char&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;table&gt;&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;后缀&lt;/th&gt;
&lt;th&gt;最小匹配类型&lt;/th&gt;
&lt;th&gt;后缀&lt;/th&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;u or U&lt;/td&gt;
&lt;td&gt;unsigned&lt;/td&gt;
&lt;td&gt;f 或 F&lt;/td&gt;
&lt;td&gt;float&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;l or L&lt;/td&gt;
&lt;td&gt;long&lt;/td&gt;
&lt;td&gt;l 或 L&lt;/td&gt;
&lt;td&gt;long double&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ll or LL&lt;/td&gt;
&lt;td&gt;long long&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
</content>
 </entry>
 
 <entry>
   <title>C++ 类型转换</title>
   <link href="/2016/11/13/cpp-type-conversion"/>
   <updated>2016-11-13T00:00:00+00:00</updated>
   <id>/2016/11/13/cpp-type-conversion</id>
   <content type="html">&lt;p&gt;C++的类型转换比较杂，看了又忘，再看也忘。在此，总结了一下。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;toc_0&quot;&gt;隐式转换&lt;/h2&gt;

&lt;h3 id=&quot;toc_1&quot;&gt;何时发生隐式转换&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;在大多数表达式中，比&lt;code&gt;int&lt;/code&gt;类型小的整型值首先提升为较大的整数类型（整型提升）。&lt;/li&gt;
&lt;li&gt;在条件中，非布尔值转换成布尔类型。&lt;/li&gt;
&lt;li&gt;初始化过程中，初始化值转换成变量类型；在赋值语句中，右侧运算对象转换成左侧运算对象的类型。&lt;/li&gt;
&lt;li&gt;如果算术运算或关系运算的运算有多种类型，需要转换成一种类型（算术转换）。&lt;/li&gt;
&lt;li&gt;函数调用时也会发生类型转换。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;toc_2&quot;&gt;转换规则&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;算术转换&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;运算符的对象转换成最宽的对象。当表达式中既有浮点型也有整型类型时，整型值也转换成浮点型。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;整型提升&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;小整数类型转换成较大的整数类型，对于&lt;code&gt;bool&lt;/code&gt;、&lt;code&gt;char&lt;/code&gt;、&lt;code&gt;signed char&lt;/code&gt;、&lt;code&gt;unsigned char&lt;/code&gt;、&lt;code&gt;short&lt;/code&gt;和&lt;code&gt;unsigned short&lt;/code&gt;，只要它们所有可能的值都能存在&lt;code&gt;int&lt;/code&gt;里，它们就会提升成&lt;code&gt;int&lt;/code&gt;类型，否则提升成&lt;code&gt;unsigned int&lt;/code&gt;类型。&lt;/p&gt;

&lt;p&gt;较大的&lt;code&gt;char&lt;/code&gt;类型（&lt;code&gt;wchar_t&lt;/code&gt;、&lt;code&gt;char16_t&lt;/code&gt;、&lt;code&gt;char32_t&lt;/code&gt;）提升成&lt;code&gt;int&lt;/code&gt;、&lt;code&gt;unsigned int&lt;/code&gt;、&lt;code&gt;long&lt;/code&gt;、&lt;code&gt;unsigned long&lt;/code&gt;、&lt;code&gt;long long&lt;/code&gt;和&lt;code&gt;unsigned long long&lt;/code&gt;中最小的一种类型。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;无符号类型的运算对象&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;首先进行整型提升，提升后如果符号相同则小类型转换大类型。如果符号不同，而其中无符号类型不小于带符号类型，则都转成无符号的；如果带符号类型大于无符号类型，如果无符号类型的所有值都能存在带符号类型中，则无符号转成带符号，如果不能，那么带符号转换无符号。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;派生类到基类转换&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;派生类型向基类类型转换只对指针或引用有效。&lt;/li&gt;
&lt;li&gt;基类向派生类不存在隐式类型转换。&lt;/li&gt;
&lt;li&gt;转换可能访问受限：

&lt;ul&gt;
&lt;li&gt;只有公有继承时，用户代码才能使用该转换。&lt;/li&gt;
&lt;li&gt;任意方式继承，成员函数和友元都能使用该转换。&lt;/li&gt;
&lt;li&gt;D 公有继承或保存继承 B 时，则 D 的派生类的成员或友元才能使用 B 向 D 的转换。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;能够将一个派生类对象拷贝、移动或赋值给一个基类对象，不过只处理派生类对象的基类部分。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;隐式的类类型转换（转换构造函数）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;能通过一个实参调用的构造函数定义了一条从构造函数的类型向类类型的隐式转换规则，只允许一步类类型转换（内置类型转换除外）。&lt;/p&gt;

&lt;p&gt;可以使用&lt;code&gt;explicit&lt;/code&gt;抑制构造函数定义的隐式转换。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;其它隐式类型转换&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;数组自动转换成指针。&lt;/li&gt;
&lt;li&gt;指针的转换：&lt;code&gt;nullptr&lt;/code&gt;能转换成任意指针类型；指向任意非常量的指针能转换成&lt;code&gt;void*&lt;/code&gt;；指向任意对象的指针能转换成&lt;code&gt;const void *&lt;/code&gt;；继承关系指针的转换。&lt;/li&gt;
&lt;li&gt;转换成布尔类型：如果指针或算术类型的值为0，转换结果为&lt;code&gt;false&lt;/code&gt;；否则转换结果是&lt;code&gt;true&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;转换成常量：指向 T 的指针或引用分别转换成指向&lt;code&gt;const T&lt;/code&gt;的指针或引用（顶层&lt;code&gt;const&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;类类型定义的转换。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;toc_3&quot;&gt;显式转换&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;static_cast&lt;/code&gt;：只要不包含底层&lt;code&gt;const&lt;/code&gt;，都可以使用&lt;code&gt;static_cast&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;const_cast&lt;/code&gt;：只能改变运算对象的底层&lt;code&gt;const&lt;/code&gt;，如果对象本身是一个常量，那么行为未定义。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;reinterpret_cast&lt;/code&gt;：为运算对象的位模式提供较底层次上的重新解释。&lt;/li&gt;
&lt;li&gt;旧式强制类型转换：
&lt;code&gt;
type (expr);
(type) expr;
&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
 </entry>
 
 <entry>
   <title>OpenWRT 启动速度优化</title>
   <link href="/2016/10/24/optimized-openwrt-boot"/>
   <updated>2016-10-24T00:00:00+00:00</updated>
   <id>/2016/10/24/optimized-openwrt-boot</id>
   <content type="html">&lt;p&gt;OpenWRT 开机到 WiFi 启动需要花费 20 多秒，实在是太慢了， 对一些简单的应用来说无法接受。经过一些尝试，我把它优化在 8 秒以内。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;toc_0&quot;&gt;移除不用的包&lt;/h2&gt;

&lt;p&gt;可以通过&lt;code&gt;make menuconfig&lt;/code&gt;来移除一些用不着的软件包，如果不用 OpenWRT 的设置网页可以去掉&lt;code&gt;luci&lt;/code&gt;软件包，如果不用上网可以移除&lt;code&gt;firewall&lt;/code&gt;等等。&lt;/p&gt;

&lt;p&gt;当然最耗时的还有一些内核模块，比如说 USB 和 I2C 驱动什么的，如果不用可以移除。可以通过&lt;code&gt;make kernel_menuconfig&lt;/code&gt;移除。&lt;/p&gt;

&lt;h2 id=&quot;toc_1&quot;&gt;启动项&lt;/h2&gt;

&lt;p&gt;可以在目录&lt;code&gt;/etc/rc.d/&lt;/code&gt;下查看启动项，不用的可以通过&lt;code&gt;/etc/init.d/&lt;/code&gt;下的脚本来禁用，比如说&lt;code&gt;telnet&lt;/code&gt;什么的。&lt;/p&gt;

&lt;h2 id=&quot;toc_2&quot;&gt;关闭 failsafe&lt;/h2&gt;

&lt;p&gt;如果不用 failsafe，可以关掉，可以省去几秒的等待时间。自行修改&lt;code&gt;/lib/&lt;/code&gt;下的脚本是没用的，得到 OpenWrt 的源码目录去修改，删掉 failsafe 的相关脚本就行。&lt;/p&gt;

&lt;h2 id=&quot;toc_3&quot;&gt;优化配置&lt;/h2&gt;

&lt;p&gt;可以优化&lt;code&gt;/etc/config/&lt;/code&gt;目录下的配置文件，无用的网络接口可以删掉。将 WiFi 的信道改成固定值可以节省非常多的时间。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Ubuntu 上自定义特殊波特率</title>
   <link href="/2016/06/30/odd-baudrate-on-ubuntu"/>
   <updated>2016-06-30T00:00:00+00:00</updated>
   <id>/2016/06/30/odd-baudrate-on-ubuntu</id>
   <content type="html">&lt;p&gt;在做嵌入式开发时，经常会需要特殊的串口波特率，比如 esp8266 的 74880 波特率。Ubuntu 下的 minicom 与 screen 都不支持这个波特率，可以使用&lt;code&gt;setserial&lt;/code&gt;将特殊波特率映射到 38400。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;我简单试了一下，PL2303 和 CH341 都不支持用&lt;code&gt;setserial&lt;/code&gt;进行特殊波特率的设置，而 FTDI 支持。&lt;/p&gt;

&lt;p&gt;首先，先安装&lt;code&gt;setserial&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;sudo apt-get install setserial
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查看&lt;code&gt;base_baud&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;sudo setserial -a /dev/ttyUSB0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我得到的&lt;code&gt;base_baud&lt;/code&gt;为 24000000。&lt;/p&gt;

&lt;p&gt;然后，进行分频：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;sudo setserial -v /dev/ttyUSB0 spd_cust divisor &lt;span class=&quot;k&quot;&gt;$((&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;24000000&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;74880&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;就可以得到特殊波特率 74880，获取其它波特率的方法过程类似。&lt;/p&gt;

&lt;p&gt;然后，只需用波特率 38400 进行连接即可。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Linux 版网易云音乐无限网络错误的解决</title>
   <link href="/2016/06/28/netease-music-network-error-solved"/>
   <updated>2016-06-28T00:00:00+00:00</updated>
   <id>/2016/06/28/netease-music-network-error-solved</id>
   <content type="html">&lt;p&gt;网易云音乐终于发布 Linux 版本了，但是在 elementaryOS 上播放音乐时出现了网络错误。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;网络上说可能是 gstreamer 依赖的问题，但没有具体的解决方法。我乱试了安装 gstreamer 的依赖，竟然让我试成功了！:satisfied:&lt;/p&gt;

&lt;p&gt;具体是安装&lt;code&gt;gstreamer0.10-plugins-good&lt;/code&gt;的依赖：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;sudo apt-get install gstreamer0.10-plugins-good
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content>
 </entry>
 
 <entry>
   <title>Shadowsocks eOS/Ubuntu 客户端</title>
   <link href="/2016/05/30/shadowsocks-ubuntu-eos-client"/>
   <updated>2016-05-30T00:00:00+00:00</updated>
   <id>/2016/05/30/shadowsocks-ubuntu-eos-client</id>
   <content type="html">&lt;p&gt;Shadowsocks-Qt5 太难用了，趁着有时间，写了一个跟 MacOS 上差不多的客户端，都是暴力 shell 调用。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;项目地址：&lt;a href=&quot;http://simpleyyt.github.io/shadowsocks-eos/&quot;&gt;http://simpleyyt.github.io/shadowsocks-eos/&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;Shadowsocks elementaryOS/Ubuntu（也许可以） 客户端（指示器）。&lt;/p&gt;

&lt;h2 id=&quot;toc_0&quot;&gt;截图&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Simpleyyt/shadowsocks-eos/master/screenshot/screenshot.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;h2 id=&quot;toc_1&quot;&gt;功能&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Shadowsocks 指示器，可以开关 Shadowsocks&lt;/li&gt;
&lt;li&gt;全局代理与自动代理模式&lt;/li&gt;
&lt;li&gt;编辑服务器&lt;/li&gt;
&lt;li&gt;获取GWFList更新&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;toc_2&quot;&gt;安装&lt;/h2&gt;

&lt;p&gt;首先必须先安装&lt;code&gt;shadowsocks&lt;/code&gt;与&lt;code&gt;gfwlist2pac&lt;/code&gt;，可以通过&lt;code&gt;pip&lt;/code&gt;安装：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;sudo pip install shadowsocks gfwlist2pac
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后，下载 Shadowsocks 的 deb 包进行安装：&lt;a href=&quot;https://github.com/simpleyyt/shadowsocks-eos/releases&quot;&gt;https://github.com/simpleyyt/shadowsocks-eos/releases&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&quot;toc_3&quot;&gt;Bugs&lt;/h2&gt;

&lt;p&gt;代码很暴力，凑合能用就行。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Linux 上 Web 版本微信发布</title>
   <link href="/2016/04/24/web-weixin-on-linux"/>
   <updated>2016-04-24T00:00:00+00:00</updated>
   <id>/2016/04/24/web-weixin-on-linux</id>
   <content type="html">&lt;p&gt;elementaryOS 或 Ubuntu 上的 Web 版微信应用。添加了 AppIndicator 消息提醒及 Libnotify 消息提醒功能。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Simpleyyt/web-weixin/master/screenshot/main.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;h1 id=&quot;toc_0&quot;&gt;功能&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;完整的 Web 微信功能&lt;/li&gt;
&lt;li&gt;独立的窗口扫码界面&lt;/li&gt;
&lt;li&gt;支持 AppIndicator 并有蓝点提示消息功能。&lt;/li&gt;
&lt;li&gt;支持 libnotify 消息提醒。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;toc_1&quot;&gt;截图&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Simpleyyt/web-weixin/master/screenshot/indicator.png&quot; alt=&quot;libnotify 提醒&quot;&gt;&lt;/p&gt;

&lt;h1 id=&quot;toc_2&quot;&gt;安装&lt;/h1&gt;

&lt;p&gt;添加 PPA 并安装：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;sudo add-apt-repository ppa:simpleyyt/ppa
sudo apt-get update
sudo apt-get install web-weixin
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id=&quot;toc_3&quot;&gt;依赖&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;gobject-2.0&lt;/li&gt;
&lt;li&gt;glib-2.0&lt;/li&gt;
&lt;li&gt;gio-2.0&lt;/li&gt;
&lt;li&gt;gtk+-3.0&amp;gt;=3.12&lt;/li&gt;
&lt;li&gt;webkit2gtk-4.0&lt;/li&gt;
&lt;li&gt;appindicator3-0.1&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;toc_4&quot;&gt;编译&lt;/h1&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;mkdir build
&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;build
cmake .. -DCMAKE_INSTALL_PREFIX&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/usr
make
sudo make install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id=&quot;toc_5&quot;&gt;Bugs&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;有时候需要退2次才能退出程序。&lt;/li&gt;
&lt;/ul&gt;
</content>
 </entry>
 
 <entry>
   <title>如何上传 ppa</title>
   <link href="/2016/04/24/how-to-upload-to-ppa"/>
   <updated>2016-04-24T00:00:00+00:00</updated>
   <id>/2016/04/24/how-to-upload-to-ppa</id>
   <content type="html">&lt;p&gt;简单记录一下 如何上传包到 launchpad 的 ppa上。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h1 id=&quot;toc_0&quot;&gt;生成 debian 目录&lt;/h1&gt;

&lt;p&gt;在终端中输入：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;dh_make --createorig
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;便会生成&lt;code&gt;debian&lt;/code&gt;目录，并且有&lt;code&gt;.orig.tar.gz&lt;/code&gt;源码包。&lt;/p&gt;

&lt;p&gt;根据需要修改&lt;code&gt;debian&lt;/code&gt;目录里面的相应内容。&lt;/p&gt;

&lt;h1 id=&quot;toc_1&quot;&gt;上传 ppa&lt;/h1&gt;

&lt;p&gt;在终端中输入：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;dput ppa:&amp;lt;userid&amp;gt;/&amp;lt;ppa-name&amp;gt; &amp;lt;source.changes&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;即可将软件包上传到 PPA 上。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>在 Cygwin 上编译 Contiki</title>
   <link href="/2015/10/26/contiki-cygwin"/>
   <updated>2015-10-26T00:00:00+00:00</updated>
   <id>/2015/10/26/contiki-cygwin</id>
   <content type="html">&lt;p&gt;由于使用 Contiki 需要 Linux 环境，切换来切换去很麻烦，幸好 Windows 下面有 Unix 模拟环境软件，Cygwin。本文主要介绍 8051 核的 Contiki 编译，它的编译需要编译器 SDCC，所以本文介绍 SDCC 的编译。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;官方 8051 核的编译文档请参考 &lt;a href=&quot;https://github.com/contiki-os/contiki/wiki/8051-Requirements&quot;&gt;8051 Requirements&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;注：官方的 win32 版的 SDCC 并不适用。&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;toc_0&quot;&gt;依赖&lt;/h2&gt;

&lt;p&gt;必须确定安装以下依赖包，可以从 Cygwin 源中直接找到：&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;gcc&lt;/li&gt;
&lt;li&gt;flex&lt;/li&gt;
&lt;li&gt;bison&lt;/li&gt;
&lt;li&gt;libboost-graph-dev&lt;/li&gt;
&lt;li&gt;python&lt;/li&gt;
&lt;li&gt;make&lt;/li&gt;
&lt;li&gt;texinfo&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;此外，还需要安装一个工具，&lt;a href=&quot;http://srecord.sourceforge.net/&quot;&gt;srecord&lt;/a&gt;，下载 Win32 版本后，直接放于&lt;code&gt;cygwin/bin/&lt;/code&gt;目录下即可。&lt;/p&gt;

&lt;h2 id=&quot;toc_1&quot;&gt;编译 SDCC&lt;/h2&gt;

&lt;h3 id=&quot;toc_2&quot;&gt;SDCC 源码下载&lt;/h3&gt;

&lt;p&gt;直接使用&lt;code&gt;svn&lt;/code&gt;下载即可，本文版本为**9377**：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;svn co svn://svn.code.sf.net/p/sdcc/code/trunk/sdcc
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;toc_3&quot;&gt;SDCC 源码修改&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;编辑&lt;code&gt;device/lib/incl.mk&lt;/code&gt;，找到：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-makefile&quot; data-lang=&quot;makefile&quot;&gt;&lt;span class=&quot;nv&quot;&gt;MODELS&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; small medium large
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;修改成&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-makefile&quot; data-lang=&quot;makefile&quot;&gt;&lt;span class=&quot;nv&quot;&gt;MODELS&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; small large huge
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;编译&lt;code&gt;device/lib/Makefile.in&lt;/code&gt;，找到：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-makefile&quot; data-lang=&quot;makefile&quot;&gt;&lt;span class=&quot;nv&quot;&gt;TARGETS&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; models small-mcs51-stack-auto
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;修改成：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-makefile&quot; data-lang=&quot;makefile&quot;&gt;&lt;span class=&quot;nv&quot;&gt;TARGETS&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; models model-mcs51-stack-auto
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;toc_4&quot;&gt;编译&lt;/h3&gt;

&lt;p&gt;进行配置：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;./configure --disable-gbz80-port --disable-z80-port --disable-ds390-port --disable-ds400-port --disable-pic14-port --disable-pic16-port --disable-hc08-port --disable-r2k-port --disable-z180-port --disable-sdcdb --disable-ucsim
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;编译并安装：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;make
make install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;toc_5&quot;&gt;试用&lt;/h2&gt;

&lt;p&gt;在 Contiki 的&lt;code&gt;example/hello-world&lt;/code&gt;目录下运行：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;make &lt;span class=&quot;nv&quot;&gt;TARGET&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;cc2530dk all
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;便可以生成&lt;code&gt;hello-world.hex&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;用 SmartRF Flash 工具便可以下载。&lt;/p&gt;

&lt;h2 id=&quot;toc_6&quot;&gt;关于编译 cc-tool&lt;/h2&gt;

&lt;p&gt;还是别折腾了，因为 cygwin 下，libusb 不支持。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>HP Chromebook 11 折腾体验</title>
   <link href="/2015/10/25/hp-chromebook-reviews"/>
   <updated>2015-10-25T00:00:00+00:00</updated>
   <id>/2015/10/25/hp-chromebook-reviews</id>
   <content type="html">&lt;p&gt;前不久淘了一台 Chromebook，hp chromebook 11，ARM 架构。外观挺新的，轻巧方便。11吋的屏幕，可以随身携带。只带 ChromeOS，开机快速，浏览网页也挺快，挺流畅的，基本不卡。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;toc_0&quot;&gt;翻墙问题&lt;/h2&gt;

&lt;p&gt;本来用的是红杏进行翻墙，后来再阅兵前红杏挂了，一直都没有找到替找品，所幸学校的网络是可以上 Google 的，所以也就没有太在意。:sunglasses:&lt;/p&gt;

&lt;h2 id=&quot;toc_1&quot;&gt;电池及续航&lt;/h2&gt;

&lt;p&gt;说实话，这台二手的 Chromebook续航能力不是很好，充满电也就能用3、4个小时，由于没有配充电器，用1A以下的充电器根本充不进去；用2A的充电器充电时，也会提示低功率充电。&lt;/p&gt;

&lt;p&gt;这算是这台机子不尽人意的一个地方。&lt;/p&gt;

&lt;h2 id=&quot;toc_2&quot;&gt;能否用作写代码&lt;/h2&gt;

&lt;p&gt;作为程序员，最关心的便是能否用它来写代码。Chromebook 用来写 javascript 还是不错的，毕竟 ChromeOS 本身就是 Chrome 浏览器，对于 Web 开发者来说是福音，Chrome Web App Store 上有好多 IDE。&lt;/p&gt;

&lt;p&gt;除了 Javascript 之外，还有 python shell，lua shell，等等可以玩玩，但是做工程就算了吧。&lt;/p&gt;

&lt;p&gt;在 ChromeOS 上写 Chrome 应用也不错，应用商店提供了 Develop IDE，只是在本 Chromebook 上跑起来有点卡:worried:。&lt;/p&gt;

&lt;p&gt;ChromeOS 还提供了一个 NaCl Development Environment，上面有一本堆 shell 工具，比 crosh 好太多了，有 git，vim 之类的，但是不能访问下载目录。在本 chromebook 也不支持 gcc 编译器:weary: :sob:。&lt;/p&gt;

&lt;h2 id=&quot;toc_3&quot;&gt;开发者模式与 crouton&lt;/h2&gt;

&lt;p&gt;可以进行开发模式，这样的 crosh 就可以支持 linux shell 一样的指令。但是每次开机都得按 Ctrl + D，挺麻烦的，所以就没搞过。&lt;/p&gt;

&lt;p&gt;crouton 是以 chroot 的方式，在 ARM 架构下也没有什么用，而且性能也不高，所以还是建议不要折腾。&lt;/p&gt;

&lt;h2 id=&quot;toc_4&quot;&gt;Web IDE&lt;/h2&gt;

&lt;p&gt;写代码的另一种方式当然是 Web IDE 了，我试用了一下，Cloud9，Koding 都挺不错的，但是在墙内可能有点慢。&lt;/p&gt;

&lt;h2 id=&quot;toc_5&quot;&gt;ARC&lt;/h2&gt;

&lt;p&gt;在 Chromebook 运行 Android 应用，缺点是大部分运行都出问题了，而且速度也挺慢，分辨率感人。&lt;/p&gt;

&lt;h2 id=&quot;toc_6&quot;&gt;感受&lt;/h2&gt;

&lt;p&gt;整台 hp chromebook 11 的感觉还是不错的，至少比平板好，而且这个价，值得。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Jekyll Editor 使用入门</title>
   <link href="/2015/10/11/jekyll-editor-tutorial"/>
   <updated>2015-10-11T00:00:00+00:00</updated>
   <id>/2015/10/11/jekyll-editor-tutorial</id>
   <content type="html">&lt;p&gt;Jekyll Editor 专门为 Jekyll 博客定制的强大的 markdown 编辑器，它会自动从&lt;code&gt;&amp;lt;yourname&amp;gt;.github.io&lt;/code&gt;仓库读取&lt;code&gt;_post&lt;/code&gt;目录下的博客列表，并可以读取、创建、修改博客。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;toc_0&quot;&gt;项目&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Github&lt;/strong&gt;：&lt;a href=&quot;https://github.com/Simpleyyt/jekyll-editor.git&quot;&gt;https://github.com/Simpleyyt/jekyll-editor.git&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Chrome 商店&lt;/strong&gt;：&lt;a href=&quot;https://chrome.google.com/webstore/detail/jekyll-editor/dfdkgbhjmllemfblfoohhehdigokocme&quot;&gt;https://chrome.google.com/webstore/detail/jekyll-editor/dfdkgbhjmllemfblfoohhehdigokocme&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;toc_1&quot;&gt;主要功能&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;获取博文列表，发布、更新、修改博文&lt;/li&gt;
&lt;li&gt;博文自动保存到本地&lt;/li&gt;
&lt;li&gt;强大的 Markdown 编辑器&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;toc_2&quot;&gt;使用说明&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;http://simpleyyt.qiniudn.com/15-10-11/10214115.jpg&quot; alt=&quot;Jekyll Editor&quot;&gt;&lt;/p&gt;

&lt;p&gt;左上角为编辑器的常用工具，包含&lt;code&gt;emoji&lt;/code&gt;表情。右上角的工具依次为登录、全窗口预览、新博文、博文列表、元数据、提交博文，帮助、关于。&lt;/p&gt;

&lt;p&gt;首次使用时，必须先进行登录，也就是与 github 相连。&lt;/p&gt;

&lt;h3 id=&quot;toc_3&quot;&gt;博文列表&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://simpleyyt.qiniudn.com/15-10-11/12709365.jpg&quot; alt=&quot;博文列表&quot;&gt;&lt;/p&gt;

&lt;p&gt;博文列表会自动获取&lt;code&gt;&amp;lt;yourname.github.io&lt;/code&gt;仓库读取&lt;code&gt;_post&lt;/code&gt;目录下&lt;code&gt;&amp;lt;date&amp;gt;-&amp;lt;slug&amp;gt;.md&lt;/code&gt;格式的文件，即为博文。&lt;/p&gt;

&lt;h3 id=&quot;toc_4&quot;&gt;元数据&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://simpleyyt.qiniudn.com/15-10-11/85340312.jpg&quot; alt=&quot;元数据&quot;&gt;&lt;/p&gt;

&lt;p&gt;即博文的 yaml 格式数据，博文将会以文件名&lt;code&gt;&amp;lt;date&amp;gt;-&amp;lt;slug&amp;gt;.md&lt;/code&gt;的格式更新。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;注：当“发布”打勾时，才会真正地发布。&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;toc_5&quot;&gt;已知 Bug&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;在获取博文列表时，可能会由于多方面原因卡死&lt;/li&gt;
&lt;li&gt;预览窗口的滚动条有时会出现问题&lt;/li&gt;
&lt;li&gt;发布时可能会卡死&lt;/li&gt;
&lt;/ul&gt;
</content>
 </entry>
 
 <entry>
   <title>Jekyll Editor 应用上线</title>
   <link href="/2015/10/11/jekyll-editor-online"/>
   <updated>2015-10-11T00:00:00+00:00</updated>
   <id>/2015/10/11/jekyll-editor-online</id>
   <content type="html">&lt;p&gt;Jekyll Editor 的 Chrome App 版本终于发布，具体地址为：&lt;a href=&quot;https://chrome.google.com/webstore/detail/jekyll-editor/dfdkgbhjmllemfblfoohhehdigokocme?hl=zh-CN&quot;&gt;Jekyll Editor&lt;/a&gt;。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;为了发布这个应用我真是费了好多心思，因为本人并没有 VISA 卡，也没有信用卡。我想到了一个神奇的网站，不是58，而是淘宝，搜了好久之后，发现有一种叫 VISA 虚拟卡，但是好像不能用，可能会被禁:flushed:。&lt;/p&gt;

&lt;p&gt;当然，还有一种是在线帮忙开，费用非常贵，要200多块，我还是咬咬牙就拍了:sob:。说多了都是泪，哎。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Chrome App 地址为：&lt;a href=&quot;https://chrome.google.com/webstore/detail/jekyll-editor/dfdkgbhjmllemfblfoohhehdigokocme?hl=zh-CN&quot;&gt;https://chrome.google.com/webstore/detail/jekyll-editor/dfdkgbhjmllemfblfoohhehdigokocme?hl=zh-CN&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>写 Jekyll 博客工具</title>
   <link href="/2015/10/09/tool-for-jekyll-blog"/>
   <updated>2015-10-09T00:00:00+00:00</updated>
   <id>/2015/10/09/tool-for-jekyll-blog</id>
   <content type="html">&lt;p&gt;上次说要写一个类似 stackeditor 的东西来写 Jekyll 博客，终于写好了。这将是第一篇用该工具写的博客。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;详细的说明将会在发布之后再说:smiley:，它是 Chrome App，基于 Editor.md 的一个应用，挺不错的，该有的都有，就是有时候有会 Bug，:disappointed_relieved:。但是没事，我以后会慢慢改进。&lt;/p&gt;

&lt;p&gt;我已经把代码 push 到 github 上去了，项目地址：&lt;a href=&quot;https://github.com/Simpleyyt/jekyll-editor.git&quot;&gt;https://github.com/Simpleyyt/jekyll-editor.git&lt;/a&gt;，写得有点乱，以后再慢慢重构。还有一个重要的问题，我没有 chrome 开发者账号:frowning:，好惨。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://simpleyyt.qiniudn.com/15-10-9/34912413.jpg&quot; alt=&quot;Jekyll Editor 截图&quot;&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>TCP 之保活计时器</title>
   <link href="/2015/09/23/tcp-keepalive-timer"/>
   <updated>2015-09-23T00:00:00+00:00</updated>
   <id>/2015/09/23/tcp-keepalive-timer</id>
   <content type="html">&lt;p&gt;保活计时器并不是 TCP 规范中的一部分，是一个有争论的功能。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;如果一个给定的连接在两个小时之内没有任何动作，则服务器就向客户发送一个探查报文段，客户机有如下状态：&lt;/p&gt;

&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;客户机仍正常运行，回复响应。服务器在两小时以后将保活定时器复位。&lt;/li&gt;
&lt;li&gt;客户机已崩溃，TCP 都没有响应，75秒后超时。服务器总共发10个这样的探查，每个间隔75秒。&lt;/li&gt;
&lt;li&gt;客户机已重新启动，客户机回复 RST。&lt;/li&gt;
&lt;li&gt;客户机正常运行，但是服务不可到达，与状态2相同。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
</content>
 </entry>
 
 <entry>
   <title>字节对齐</title>
   <link href="/2015/09/23/data-structure-alignmen"/>
   <updated>2015-09-23T00:00:00+00:00</updated>
   <id>/2015/09/23/data-structure-alignmen</id>
   <content type="html">&lt;p&gt;Linux 沿用的对齐策略是，2字节数据类型（例如&lt;code&gt;short&lt;/code&gt;）的地址是2的倍数，而较大的数据类型（例如&lt;code&gt;int&lt;/code&gt;、&lt;code&gt;int*&lt;/code&gt;、&lt;code&gt;float&lt;/code&gt;和&lt;code&gt;double&lt;/code&gt;）的地址必须是4的倍数。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;Windows 要求任何 K 字节基本对象的址址必须是 K 的倍数，K = 2, 4 或者 8。特别的，它要求一个&lt;code&gt;double&lt;/code&gt;或者&lt;code&gt;long long&lt;/code&gt;类型数据的地址应该是8的倍数。&lt;/p&gt;

&lt;h2 id=&quot;toc_0&quot;&gt;对齐准则&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;四个重要的基本概念：&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;数据类型自身的对齐值：char型数据自身对齐值为1字节，short型数据为2字节，int/float型为4字节，double型为8字节。&lt;/li&gt;
&lt;li&gt;结构体或类的自身对齐值：其成员中自身对齐值最大的那个值。&lt;/li&gt;
&lt;li&gt;指定对齐值：#pragma pack (value)时的指定对齐值value。&lt;/li&gt;
&lt;li&gt;数据成员、结构体和类的有效对齐值：自身对齐值和指定对齐值中较小者，即有效对齐值=min{自身对齐值，当前指定的pack值}。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;其中，有效对齐值&lt;code&gt;N&lt;/code&gt;是最终用来决定数据存放地址方式的值。有效对齐&lt;code&gt;N&lt;/code&gt;表示**“对齐在&lt;code&gt;N&lt;/code&gt;上”**，即该数据的**“存放起始地址 % N = 0”**。而数据结构中的数据变量都是按定义的先后顺序存放。第一个数据变量的起始地址就是数据结构的起始地址。结构体的成员变量要对齐存放，结构体本身也要根据自身的有效对齐值圆整(即结构体成员变量占用总长度为结构体有效对齐值的整数倍)。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;例1：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;short&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;short&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;结果：&lt;/strong&gt;&lt;code&gt;sizeof(strcut A)&lt;/code&gt;值为8；&lt;code&gt;sizeof(struct B)&lt;/code&gt;的值却是12。 &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;例2：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;cp&quot;&gt;#pragma pack(2)  //指定按2字节对齐
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;short&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#pragma pack()   //取消指定对齐，恢复缺省对齐
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;结果：&lt;/strong&gt;&lt;code&gt;sizeof(struct C) = 8&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&quot;toc_1&quot;&gt;栈内存对齐&lt;/h2&gt;

&lt;p&gt;在VC/C++中，栈的对齐方式不受结构体成员对齐选项的影响。总是保持对齐且对齐在4字节边界上。（并未考证64位）&lt;/p&gt;

&lt;h2 id=&quot;toc_2&quot;&gt;位域对齐&lt;/h2&gt;

&lt;p&gt;位域成员不能单独被取&lt;code&gt;sizeof&lt;/code&gt;值。下面主要讨论含有位域的结构体的&lt;code&gt;sizeof&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;C99 规定&lt;code&gt;int&lt;/code&gt;、&lt;code&gt;unsigned int&lt;/code&gt;和&lt;code&gt;bool&lt;/code&gt;可以作为位域类型，但编译器几乎都对此作了扩展，允许其它类型的存在。位域作为嵌入式系统中非常常见的一种编程工具，优点在于压缩程序的存储空间。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;其对齐规则大致为：&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;如果相邻位域字段的类型相同，且其位宽之和小于类型的&lt;code&gt;sizeof&lt;/code&gt;大小，则后面的字段将紧邻前一个字段存储，直到不能容纳为止；&lt;/li&gt;
&lt;li&gt;如果相邻位域字段的类型相同，但其位宽之和大于类型的&lt;code&gt;sizeof&lt;/code&gt;大小，则后面的字段将从新的存储单元开始，其偏移量为其类型大小的整数倍；&lt;/li&gt;
&lt;li&gt;如果相邻的位域字段的类型不同，则各编译器的具体实现有差异，VC6 采取不压缩方式，Dev-C++ 和 GCC 采取压缩方式；&lt;/li&gt;
&lt;li&gt;如果位域字段之间穿插着非位域字段，则不进行压缩；&lt;/li&gt;
&lt;li&gt;整个结构体的总大小为最宽基本类型成员大小的整数倍，而位域则按照其最宽类型字节数对齐。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;例3：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BitField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element1&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element2&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element3&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;位域类型为&lt;code&gt;char&lt;/code&gt;，第1个字节仅能容纳下&lt;code&gt;element1&lt;/code&gt;和&lt;code&gt;element2&lt;/code&gt;，所以&lt;code&gt;element1&lt;/code&gt;和&lt;code&gt;element2&lt;/code&gt;被压缩到第1个字节中，而&lt;code&gt;element3&lt;/code&gt;只能从下一个字节开始。因此&lt;code&gt;sizeof(BitField)&lt;/code&gt;的结果为2。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;例4：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;StructBitField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element1&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element2&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element3&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;29&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element4&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element5&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stelement&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;//在含位域的结构或联合中也可同时说明普通成员
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;位域中最宽类型&lt;code&gt;int&lt;/code&gt;的字节数为4，因此结构体按4字节对齐，在 VC6 中其&lt;code&gt;sizeof&lt;/code&gt;为16。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;例5：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BitField4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element1&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element3&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;长度为0的位域告诉编译器将下一个位域放在一个存储单元的起始位置。如上，编译器会给成员&lt;code&gt;element1&lt;/code&gt;分配3位，接着跳过余下的4位到下一个存储单元，然后给成员&lt;code&gt;element3&lt;/code&gt;分配5位。故上面的结构体大小为2。&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;&lt;em&gt;本文参考：&lt;a href=&quot;http://www.cnblogs.com/clover-toeic/p/3853132.html&quot;&gt;http://www.cnblogs.com/clover-toeic/p/3853132.html&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
</content>
 </entry>
 
 
</feed>
