

<!DOCTYPE html>
<!--[if lt IE 7]> <html class="no-js lt-ie9 lt-ie8 lt-ie7 ie" lang="en"> <![endif]-->
<!--[if IE 7]>    <html class="no-js lt-ie9 lt-ie8 ie" lang="en"> <![endif]-->
<!--[if IE 8]>    <html class="no-js lt-ie9 ie" lang="en"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"> <!--<![endif]-->
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width,initial-scale=1">
	<title>Docker</title>
	<meta name="author" content="kangkangliang">
	<link href='/assets/themes/the-program/css/style.css' rel="stylesheet" media="all">
	<link href="http://feeds.feedburner.com/" rel="alternate" title="Docker" type="application/atom+xml">
	<script src="http://cdnjs.cloudflare.com/ajax/libs/modernizr/2.0.6/modernizr.min.js"></script>
</head>
<body>

<div id="page" class="hentry">
	<header class="the-header">
		<div class="unit-head">
			<div class="unit-inner unit-head-inner">
				<nav class="nav-global">
					<ul>
						<li class="logo"><a href="/">既生而为人，就要承担，安然接受人生可能发生的一切。</a></li>
						<li class="archive"><a href="/archive.html">archive</a></li>
						<li class="page"><a href="/pages.html">pages</a></li>
						<li class="category"><a href="/categories.html">categories</a></li>
						<li class="tag"><a href="/tags.html">tags</a></li>
						<li class="forkme"><div><iframe src="http://markdotto.github.com/github-buttons/github-btn.html?user=plusjade&repo=jekyll-bootstrap&type=fork&count=true"
									allowtransparency="true" frameborder="0" scrolling="0" width="95px" height="20px"></iframe></div></li>
					</ul>
				</nav>
			</div><!-- unit-inner -->
		</div><!-- unit-head -->
	</header>
	<div class="body" role="main">
		<div class="unit-body">
			<div class="unit-inner unit-body-inner">
				<div class="entry-content">
					

<article class="unit-article layout-post">
	<div class="unit-inner unit-article-inner">
		<div class="content">
			<header>
				<div class="unit-head">
					<div class="unit-inner unit-head-inner">
						<h1 class="h2 entry-title">Docker</h1>
					</div><!-- unit-inner -->
				</div><!-- unit-head -->
			</header>

			<div class="bd">
				<div class="entry-content">
					
<h1 class="no_toc" id="overview">Overview</h1>

<ul id="markdown-toc">
  <li><a href="#docker-learn-note" id="markdown-toc-docker-learn-note">Docker learn note</a></li>
  <li><a href="#docker" id="markdown-toc-docker">安装Docker</a></li>
  <li><a href="#section" id="markdown-toc-section">核心概念</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">拉取和推送</a></li>
  <li><a href="#section-2" id="markdown-toc-section-2">制作镜像</a></li>
  <li><a href="#section-3" id="markdown-toc-section-3">挂载本地目录</a></li>
  <li><a href="#section-4" id="markdown-toc-section-4">导入和导出镜像</a></li>
  <li><a href="#section-5" id="markdown-toc-section-5">数据卷</a></li>
  <li><a href="#section-6" id="markdown-toc-section-6">网络配置</a></li>
  <li><a href="#docker-cmd" id="markdown-toc-docker-cmd">Docker cmd</a></li>
  <li><a href="#dockerfile" id="markdown-toc-dockerfile">Dockerfile</a></li>
  <li><a href="#problem" id="markdown-toc-problem">Problem</a></li>
</ul>

<h2 id="docker-learn-note">Docker learn note</h2>

<ul>
  <li><a href="http://blog.opskumu.com/docker.html">Kumu-docker</a></li>
  <li>
    <p><a href="http://blog.daocloud.io/how-to-master-docker-image/">玩转Docker</a></p>
  </li>
  <li><a href="http://dev.aliyun.com/search.html">阿里云加速</a></li>
</ul>

<hr />

<h2 id="docker">安装Docker</h2>

<p>Ubuntu:14.04中安装</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$sudo apt-get update
$sudo apt-get install apt-transport-https ca-certificates
$sudo apt-key adv --keyserver hkp://ha.pool.sks-keyservers.net:80 --recv-keys 58118E89F3A912897C070ADBF76221572C52609D
$ echo "deb https://apt.dockerproject.org/repo ubuntu-trusty main" | sudo tee /etc/apt/sources.list.d/docker.list
$sudo apt-get update
$sudo apt-get install docker-engine
$sudo service docker start
$sudo docker run hello-world
</code></pre>
</div>

<p>卸载Docker</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$sudo apt-get purge docker-engine
$sudo apt-get autoremove --purge docker-engine
$rm -rf /var/lib/docker
</code></pre>
</div>

<p>升级Docker</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$sudo apt-get update
$sudo apt-get upgrade docker-engine
</code></pre>
</div>

<p>官网<a href="https://docs.docker.com/engine/installation/linux/ubuntulinux/">https://docs.docker.com/engine/installation/linux/ubuntulinux/</a></p>

<h2 id="section">核心概念</h2>

<p>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。</p>

<p>Docker有三大核心概念：镜像（Image）、容器（Container）、仓库（Repository）。</p>

<h2 id="section-1">拉取和推送</h2>

<ul>
  <li>拉取</li>
</ul>

<p>首先，我们通过docker search image-name来搜索需要的镜像。然后通过docker pull image-name 来拉取镜像。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>sudo docker pull name[:TAG]
sudo docker pull ubuntu:latest
</code></pre>
</div>

<ul>
  <li>推送</li>
</ul>

<p>通过拉取基本的镜像之后，我们可以通过Dockfile或者commit来构建镜像，一般都会选择Dockfile来构建自己需要的镜像.</p>

<p>推送镜像的时候，我们需要登录dockerhub或者daocloud的网站进行注册，在需要推送的机器上使用命令登录</p>

<div class="highlighter-rouge"><pre class="highlight"><code>docker login
</code></pre>
</div>

<p>查看信息</p>

<div class="highlighter-rouge"><pre class="highlight"><code>cat .dockercfg
</code></pre>
</div>

<p>我们可以使用docker tag	来添加自己的名字。用docker images来查看镜像</p>

<div class="highlighter-rouge"><pre class="highlight"><code>docker push daocloud-name/repo-name:latest
</code></pre>
</div>

<p>通过上面的命令就可以推送到dockerhub或者daocloud上，我们可以看到自己推送的tag，但是在推送之前必须把使用该镜像的容器stop，否则不能推送成功。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>docker push daocloud-name/repo-name:v1
</code></pre>
</div>

<hr />

<h2 id="section-2">制作镜像</h2>

<p>两种方式制作镜像</p>

<ul>
  <li>docker commit命令</li>
</ul>

<p>操作完之后，我们通过docker commit image-id daocloud-user-name/repo-name,通过docker images daocloud-user-name/repo-name来检查刚才创建的镜像</p>

<p>提交一个新的定制的镜像，docker commit -m “A new custom image” -a “author info” image-id daocloud-user-name/repo-name:context</p>

<p>-m:来指定新的镜像的提交信息</p>

<p>-a:列出该镜像的作者信息</p>

<p>daocloud-user-name/repo-name:指定了镜像的用户名和仓库名，并且为该镜像增加了一个context的标签。</p>

<p>可以使用docker inspect命令来查看新创建的镜像的详细信息.docker inspect daocloud-user-name/repo-name:context</p>

<p>从新提交的镜像运行一个新的容器，docker run -it daocloud-user-name/repo-name:context /bin/bash可以看出我们用了完整的标签来指定这个镜像。</p>

<ul>
  <li>使用docker build命令和Dockfile文件(推荐)</li>
</ul>

<p>简单demo:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>mkdir first-docker-file
cd first-docker-file
touch Dockfile
</code></pre>
</div>

<p>执行docker build命令时，Dockerfile中的所有指令都会被执行并且提交。并且在该命令成功结束后返回一个<code class="highlighter-rouge">新的镜像</code>。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>docker build -t="daocloud-user-name/repo-name" .
</code></pre>
</div>

<p>开始构建新的对象。如果没有指定任何tag，Docker将会自动为镜像设置一个latest标签</p>

<hr />

<h2 id="section-3">挂载本地目录</h2>

<p>docker可以把一个宿主机上的<code class="highlighter-rouge">目录</code>挂载到<code class="highlighter-rouge">镜像里</code></p>

<div class="highlighter-rouge"><pre class="highlight"><code>docker run -it -v /home/user/Downloads:/usr/share ubuntu:14.04 /bin/bash
</code></pre>
</div>

<p>通过<code class="highlighter-rouge">-v</code>参数，冒号前为<code class="highlighter-rouge">宿主机目录</code>，必须为<code class="highlighter-rouge">绝对路径</code>，冒号后面为<code class="highlighter-rouge">镜像内挂载的目录的路径</code></p>

<p>现在镜像内就可以访问共享宿主机里面的文件了。</p>

<p>默认挂载的路径<code class="highlighter-rouge">权限</code>为读写。如果指定为<code class="highlighter-rouge">只读</code>可以使用:ro</p>

<div class="highlighter-rouge"><pre class="highlight"><code>docker run -it -v /home/user/Downloads:/usr/share:ro ubuntu:14.04 /bin/bash
</code></pre>
</div>

<p>docker还提供了一个<code class="highlighter-rouge">高级</code>的用法，叫做<code class="highlighter-rouge">数据卷</code>。</p>

<p>数据卷:“其实就是一个<code class="highlighter-rouge">正常的容器</code>，专门用来提供数据卷供<code class="highlighter-rouge">其他容器挂载</code>”,感觉像是由一个容器定义的一个<code class="highlighter-rouge">数据挂载信息</code>。其他的容器启动就可以直接挂载数据卷中定义的挂载信息。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>docker run -v /home/user/Downloads:/usr/share --name dataVol ubuntu:14.04 /bin/bash
</code></pre>
</div>

<p>创建一个普通的容器。用<code class="highlighter-rouge">--name</code>给它指定一个名(不指定的话，就会随机产生一个名字)</p>

<div class="highlighter-rouge"><pre class="highlight"><code>docker ps -l
</code></pre>
</div>

<p>再创建一个新的容器，来使用这个数据卷。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>docker run -it --volumes-from dataVol ubuntu14.04 /bin/bash
</code></pre>
</div>

<p>–volumes-from用来指定要从哪个数据卷来挂载数据。同样都是在/usr/share目录下。</p>

<hr />

<h2 id="section-4">导入和导出镜像</h2>

<p>可以使用docker save和docker load来存储镜像和载入镜像</p>

<p>保存镜像</p>

<div class="highlighter-rouge"><pre class="highlight"><code>sudo docker images			#镜像列表
sudo docker save -o xxxx.jar 要保存的镜像		#保存镜像为文件
sudo docker mirrorId &gt; path/xxx.tar
sudo docker save ubuntu.tar repo/ubuntu
#完成之后用ls查看
</code></pre>
</div>

<p>加载镜像</p>

<div class="highlighter-rouge"><pre class="highlight"><code>sudo docker load --input xxx.tar
#or
sudo docker load &lt; xxx.tar
</code></pre>
</div>

<p>导出export和保存save的区别</p>

<ul>
  <li>export导出的镜像文件大小  小于 save保存的镜像</li>
  <li>export 导出（import导入）是根据容器拿到的镜像，再导入时会丢失镜像所有的历史，所以无法进行回滚操作（docker tag <LAYER ID=""> <IMAGENAME>）；而save保存（load加载）的镜像，没有丢失镜像的历史，可以回滚到之前的层（layer）。（查看方式：docker images --tree）</IMAGENAME></LAYER></li>
</ul>

<p>注：导入加载进来觉得不合适可以使用 docker rm 容器ID 、 docker rmi 镜像ID 来删掉。</p>

<p>移除所有的容器和镜像：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>docker kill $(docker ps -q) ; docker rm $(docker ps -a -q) ; docker rmi $(docker images -q -a)
</code></pre>
</div>

<hr />

<h2 id="section-5">数据卷</h2>

<div class="highlighter-rouge"><pre class="highlight"><code>docker run -it --volumes-from dataVol ubuntu14.04 /bin/bash
</code></pre>
</div>

<h2 id="section-6">网络配置</h2>

<p><strong>端口映射</strong></p>

<p>从外部访问容器应用，可以通过-p/-P参数来指定端口映射。使用-P时，Docker会随机映射一个端口到容器内部开放的端口。-p会映射到指定的端口，支持的格式有</p>

<ul>
  <li>ip地址:主机端口:容器端口</li>
  <li>ip地址::容器端口</li>
  <li>主机端口:容器端口</li>
</ul>

<p>查看映射端口配置</p>

<div class="highlighter-rouge"><pre class="highlight"><code>sudo  port containerid  port
</code></pre>
</div>

<p>容器有自己内部往来和IP地址</p>

<div class="highlighter-rouge"><pre class="highlight"><code>sudo docker inspect containerid
</code></pre>
</div>

<p>exam:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>sudo docker run -it -p 127.0.0.1:4001:4000 jekyll/jekyll /bin/bash
jekyll build
jekyll serve
</code></pre>
</div>

<p>然后通过外部浏览器来访问localhost:4001</p>

<p><strong>容器互联</strong></p>

<p>容器的连接系统是除了端口映射另外一种可以与容器中应用进行交互的方式，它会在源和接受容器之间创建一个隧道，接受容器可以看到源容器的指定的信息</p>

<div class="highlighter-rouge"><pre class="highlight"><code>sudo docker run -d -p --name blog jekyll/jekyll
</code></pre>
</div>

<p>容器的名字<code class="highlighter-rouge">必须是唯一的</code>，执行docker run 时，如果加上–rm参数，容器在终止的时候会立即被删除，但是不能与-d参数一起使用。</p>

<p>使用–link参数可以让容器直接建立安全的连接进行交互。</p>

<p>首先创建一个数据库的容器</p>

<div class="highlighter-rouge"><pre class="highlight"><code>sudo dcoker run -d --name db training/postgres
</code></pre>
</div>

<p>创建web容器</p>

<div class="highlighter-rouge"><pre class="highlight"><code>sudo docker run -d -p --name web --link db:db training/webapp python app.py
</code></pre>
</div>

<p>此时db容器和web容器相互联系。–link参数:–link name:alias,name是要连接的容器，alias是这个容器的别名，可以使用docker ps查看容器的信息，其中name列就能看出互联的状态</p>

<p>docker在两个<code class="highlighter-rouge">互联</code>容器直接建立一个<code class="highlighter-rouge">安全隧道</code>，不需要把它们的端口<code class="highlighter-rouge">映射到宿主主机上</code>，也可以避免端口的暴露。</p>

<p>Docker提供两种方式公开连接信息</p>

<ul>
  <li>环境变量</li>
  <li>更新/etc/hosts文件</li>
</ul>

<p>使用env命令可以看到容器的环境变量</p>

<hr />

<h2 id="docker-cmd">Docker cmd</h2>

<p><a href="https://docs.docker.com/engine/reference/commandline/">Dockfile-command</a></p>

<div class="highlighter-rouge"><pre class="highlight"><code>docker login
docker logout
docker diff
docker build
docker commit
docker create
docker cp
docker events
docker export
docker info
docker kill
docker pull
docker run
docker image
docker tag
docker inspect
docker search
docker rmi
docker commit
docker save
docker load
docker push
docker logs
docker ps
docker restart
docker attach
docker exec
docker top
docker stop
docker start
docker port
docker pause
docker history
docker version
docker wait
</code></pre>
</div>

<hr />

<h2 id="dockerfile">Dockerfile</h2>

<p>我们可以是Dockfile文件<code class="highlighter-rouge">快速创建自定义的镜像</code>,一般分为<code class="highlighter-rouge">4个部分</code></p>

<ul>
  <li>基础镜像信息</li>
  <li>维护者信息</li>
  <li>镜像操作指令</li>
  <li>容器启动时的执行命令</li>
</ul>

<p><strong>指令</strong></p>

<p>指令的一半格式是INSTRUCTION arguments</p>

<p><strong>FROM</strong></p>

<p>格式为:FROM <image> or FROM <image>:<tag>
Dockerfile文件第一行必须为FROM指令，如果在同一个Dockerfile创建多个镜像时，可以使用多个FROM指令(每个镜像一次)</tag></image></image></p>

<p><strong>MAINTAINER</strong></p>

<p>指定维护者信息,格式为：MAINTAINER <name></name></p>

<p><strong>RUN</strong></p>

<p>格式为RUN <command />或者RUN[“executable”,”param1”,”param2”],前者将在shell终端运行命令，即/bin/sh -c,后者在使用exec执行。第二种方式可以指定<code class="highlighter-rouge">其他终端实现</code>，如:RUN [“/bin/bash”,”-c”,”echo hello”],RUN命令将在当前镜像基础上执行执行命令,并提交为新的镜像，当命令较长时，可以使用\来换行。</p>

<p><strong>CMD</strong></p>

<p>指定启动容器时执行的命令，每个Dockerfile<code class="highlighter-rouge">只能有一条CMD命令</code>，如果指定了多个命令，只有<code class="highlighter-rouge">最后一条命令执行</code>,该命令支持三种格式：</p>

<ul>
  <li>CMD [“executable”,”param1”,”param2”]:使用exec执行</li>
  <li>CMD command param1 param2:在/bin/bash中执行，提供给需要交互的应用</li>
  <li>CMD [“param1”,”param2”]:提供给ENTRYPOINT默认参数</li>
</ul>

<p>如果在其中容器中指定了运行的命令，就会覆盖掉CMD命令</p>

<p><strong>EXPOSE</strong></p>

<p>告诉Docker服务器容器需要暴露的端口号，<code class="highlighter-rouge">供互联系统使用</code></p>

<p>格式:EXPOSE <port> [<port>...]</port></port></p>

<p>在容器启动时，需要通过-P让Docker主机自动分配一个端口转发到指定的端口，使用-p则可以具体指定哪个本地端口会映射过来。</p>

<p><strong>ENV</strong></p>

<p>指定环境变量，会被后面RUN指令使用，并在容器运行时保持</p>

<p>格式:ENV <key> <value></value></key></p>

<p><strong>ADD</strong></p>

<p>该命令向容器中复制文件</p>

<p>格式:ADD <src> <dst>
指定的src会被复制到dst，src可以是Dockerfile所在目录的一个`相对路径(文件或者目录)，也可以是一个URL，还可以是一个tar包，--会自动解包为一个目录`</dst></src></p>

<p><strong>COPY</strong></p>

<p>格式:COPY <src> <dst></dst></src></p>

<p>复制主机的<src>(Dockerfile所在的目录的相对路径，文件或目录)为容器<dst>,目标路径不存在时会自动创建。</dst></src></p>

<p><strong>ENTRYPOINT</strong></p>

<p>配置容器启动后执行的命令，并且不尅被docker run命令提供过的参数覆盖</p>

<p>格式:</p>

<ul>
  <li>ENTRYPOINT [“executable”,”param1”,”param2”]</li>
  <li>ENTRYPOINT command param1 param2:shell中执行</li>
</ul>

<p>同样的，每个Dockerfile中<code class="highlighter-rouge">只能有一个该指令，指定多个时，只有最后一个生效</code></p>

<p><strong>VOLUME</strong></p>

<p>创建一个可以从本地主机或其他容器挂载的挂载点，一般是<code class="highlighter-rouge">用来存放数据库和需要保持的数据等</code>。</p>

<p><strong>USER</strong></p>

<p>指定运行容器时用户名或UID，后续的RUN也会指定为该用户</p>

<p>格式: USER daemon</p>

<p><strong>WORKDIR</strong></p>

<p>为后续的RUN，CMD，ENTRYPOINT执行配置工作路径</p>

<p>格式:WORKDIR /path/to/workdir</p>

<p>可以使用多个该指令，后续指令如果是相对路径，则会<code class="highlighter-rouge">基于之前的命令执行路径</code></p>

<div class="highlighter-rouge"><pre class="highlight"><code>workdir /A
workdir B
RUN X
</code></pre>
</div>

<p>则最终的路径为:/A/B.</p>

<p><strong>ONBUILD</strong></p>

<p>配置当前所创建的镜像作为其他新创建镜像的基础镜像，所执行的操作指令。</p>

<p>格式:ONBUILD [INSTRUCTION]</p>

<p>比如:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>ONBUILD ADD . /app/src
ONBUILD RUN /usr/local --dir /app/src
....
</code></pre>
</div>

<p>如果基于以上继续创建新镜像时，新的Dockerfile中使用的FROM指定以上为基础镜像，会自动执行ONBUILD指令内容，等价后面添加两条指令。</p>

<p><strong>LABLE</strong></p>

<p><strong>STOPSIGNAL</strong></p>

<p><strong>ONBUILD</strong></p>

<p><strong>创建镜像</strong></p>

<p>编写好Dockerfile，可以通过docker build来创建镜像</p>

<p>基本格式:docker buidl 选项 路径</p>

<p>该命令会自动读取指定路径(包含子目录)的Dockerfile，并将路径下的所有内容发送到docker服务器，创建镜像</p>

<div class="highlighter-rouge"><pre class="highlight"><code>sudo docker build -t image_name /src/dockerfile_path
</code></pre>
</div>

<p><strong>Dockerfile</strong></p>

<div class="highlighter-rouge"><pre class="highlight"><code># Dockerfile for ELK stack
# Elasticsearch 5.0.0, Logstash 5.0.0, Kibana 5.0.0

# Build with:
# docker build -t &lt;repo-user&gt;/elk .

# Run with:
# docker run -p 5601:5601 -p 9200:9200 -p 5044:5044 -it --name elk &lt;repo-user&gt;/elk

FROM phusion/baseimage
MAINTAINER Sebastien Pujadas http://pujadas.net
ENV REFRESHED_AT 2016-10-30

###############################################################################
#                                INSTALLATION
###############################################################################

### install prerequisites (cURL, gosu)

ENV GOSU_VERSION 1.8

RUN set -x \
 &amp;&amp; apt-get update -qq \
 &amp;&amp; apt-get install -qqy --no-install-recommends ca-certificates curl \
 &amp;&amp; rm -rf /var/lib/apt/lists/* \
 &amp;&amp; curl -L -o /usr/local/bin/gosu "https://github.com/tianon/gosu/releases/download/$GOSU_VERSION/gosu-$(dpkg --print-architecture)" \
 &amp;&amp; curl -L -o /usr/local/bin/gosu.asc "https://github.com/tianon/gosu/releases/download/$GOSU_VERSION/gosu-$(dpkg --print-architecture).asc" \
 &amp;&amp; export GNUPGHOME="$(mktemp -d)" \
 &amp;&amp; gpg --keyserver hkp://ha.pool.sks-keyservers.net:80 --recv-keys B42F6819007F00F88E364FD4036A9C25BF357DD4 \
 &amp;&amp; gpg --batch --verify /usr/local/bin/gosu.asc /usr/local/bin/gosu \
 &amp;&amp; rm -r "$GNUPGHOME" /usr/local/bin/gosu.asc \
 &amp;&amp; chmod +x /usr/local/bin/gosu \
 &amp;&amp; gosu nobody true \
 &amp;&amp; apt-get clean \
 &amp;&amp; set +x


### install Elasticsearch

ENV ES_VERSION 5.0.0
ENV ES_GID 991
ENV ES_UID 991

RUN curl https://artifacts.elastic.co/GPG-KEY-elasticsearch | apt-key add -
RUN apt-get install apt-transport-https
RUN echo deb https://artifacts.elastic.co/packages/5.x/apt stable main &gt; /etc/apt/sources.list.d/elasticsearch-5.x.list

RUN groupadd -r elasticsearch -g ${ES_GID} \
 &amp;&amp; useradd -r -s /usr/sbin/nologin -M -c "Elasticsearch service user" -u ${ES_UID} -g elasticsearch elasticsearch \
 &amp;&amp; apt-get update -qq \
 &amp;&amp; apt-get install -qqy \
		elasticsearch \
		openjdk-8-jdk \
 &amp;&amp; apt-get clean


### install Logstash

ENV LOGSTASH_VERSION 5.0.0
ENV LOGSTASH_HOME /opt/logstash
ENV LOGSTASH_PACKAGE logstash-${LOGSTASH_VERSION}.tar.gz
ENV LOGSTASH_GID 992
ENV LOGSTASH_UID 992

RUN mkdir ${LOGSTASH_HOME} \
 &amp;&amp; curl -O https://artifacts.elastic.co/downloads/logstash/${LOGSTASH_PACKAGE} \
 &amp;&amp; tar xzf ${LOGSTASH_PACKAGE} -C ${LOGSTASH_HOME} --strip-components=1 \
 &amp;&amp; rm -f ${LOGSTASH_PACKAGE} \
 &amp;&amp; groupadd -r logstash -g ${LOGSTASH_GID} \
 &amp;&amp; useradd -r -s /usr/sbin/nologin -d ${LOGSTASH_HOME} -c "Logstash service user" -u ${LOGSTASH_UID} -g logstash logstash \
 &amp;&amp; mkdir -p /var/log/logstash /etc/logstash/conf.d \
 &amp;&amp; chown -R logstash:logstash ${LOGSTASH_HOME} /var/log/logstash

ADD ./logstash-init /etc/init.d/logstash
RUN sed -i -e 's#^LS_HOME=$#LS_HOME='$LOGSTASH_HOME'#' /etc/init.d/logstash \
 &amp;&amp; chmod +x /etc/init.d/logstash


### install Kibana

ENV KIBANA_VERSION 5.0.0
ENV KIBANA_HOME /opt/kibana
ENV KIBANA_PACKAGE kibana-${KIBANA_VERSION}-linux-x86_64.tar.gz
ENV KIBANA_GID 993
ENV KIBANA_UID 993

RUN mkdir ${KIBANA_HOME} \
 &amp;&amp; curl -O https://artifacts.elastic.co/downloads/kibana/${KIBANA_PACKAGE} \
 &amp;&amp; tar xzf ${KIBANA_PACKAGE} -C ${KIBANA_HOME} --strip-components=1 \
 &amp;&amp; rm -f ${KIBANA_PACKAGE} \
 &amp;&amp; groupadd -r kibana -g ${KIBANA_GID} \
 &amp;&amp; useradd -r -s /usr/sbin/nologin -d ${KIBANA_HOME} -c "Kibana service user" -u ${KIBANA_UID} -g kibana kibana \
 &amp;&amp; mkdir -p /var/log/kibana \
 &amp;&amp; chown -R kibana:kibana ${KIBANA_HOME} /var/log/kibana

ADD ./kibana-init /etc/init.d/kibana
ADD ./kibana.yml ${KIBANA_HOME}/config/kibana.yml

RUN sed -i -e 's#^KIBANA_HOME=$#KIBANA_HOME='$KIBANA_HOME'#' /etc/init.d/kibana \
 &amp;&amp; chmod +x /etc/init.d/kibana


###############################################################################
#                               CONFIGURATION
###############################################################################

### configure Elasticsearch

ADD ./elasticsearch.yml /etc/elasticsearch/elasticsearch.yml


### configure Logstash

# certs/keys for Beats and Lumberjack input
RUN mkdir -p /etc/pki/tls/certs &amp;&amp; mkdir /etc/pki/tls/private
ADD ./logstash-beats.crt /etc/pki/tls/certs/logstash-beats.crt
ADD ./logstash-beats.key /etc/pki/tls/private/logstash-beats.key

# filters
ADD ./02-beats-input.conf /etc/logstash/conf.d/02-beats-input.conf
ADD ./10-syslog.conf /etc/logstash/conf.d/10-syslog.conf
ADD ./11-nginx.conf /etc/logstash/conf.d/11-nginx.conf
ADD ./30-output.conf /etc/logstash/conf.d/30-output.conf

# patterns
ADD ./nginx.pattern ${LOGSTASH_HOME}/patterns/nginx
RUN chown -R logstash:logstash ${LOGSTASH_HOME}/patterns


### configure logrotate

ADD ./elasticsearch-logrotate /etc/logrotate.d/elasticsearch
ADD ./logstash-logrotate /etc/logrotate.d/logstash
ADD ./kibana-logrotate /etc/logrotate.d/kibana
RUN chmod 644 /etc/logrotate.d/elasticsearch \
 &amp;&amp; chmod 644 /etc/logrotate.d/logstash \
 &amp;&amp; chmod 644 /etc/logrotate.d/kibana


###############################################################################
#                                   START
###############################################################################

ADD ./start.sh /usr/local/bin/start.sh
RUN chmod +x /usr/local/bin/start.sh

EXPOSE 5601 9200 9300 5044
VOLUME /var/lib/elasticsearch

CMD [ "/usr/local/bin/start.sh" ]
</code></pre>
</div>

<hr />

<h2 id="problem">Problem</h2>

<ul>
  <li>
    <p>Repository busybox already being pulled by another client. Waiting.</p>

    <p>restart the docker : service docker restart</p>
  </li>
</ul>


					<div class="meta">
						<p class="date-publish">
							Published: 
							<date class="date-pub" title="2016-10-24T00:00:00+00:00" datetime="2016-10-24T00:00:00+00:00" pubdate>
							<span class="month"><abbr>October</abbr></span>
							<span class="day">24</span>
							<span class="year">2016</span>
							</date>
						</p>
						<ul class="list-category list-linear">
							<li class="list-head">category: </li>
							
							


  
     
    	<li><a href="/categories.html#Docker-ref">
    		Docker <span>1</span>
    	</a></li>
    
  


						</ul>
						<ul class="list-tag list-linear">
							<li class="list-head">tags: </li>
							
							


  
     
    	<li><a href="/tags.html#docker-ref">docker <span>1</span></a></li>
    
  



						</ul>
					</div><!-- meta -->
				</div><!-- entry-content -->
				<div class="misc-content">
					<div class="social">
						<ul class="list-linear">
							<li><div class="twitter-tweet"><a href="https://twitter.com/share" class="twitter-share-button" data-count="horizontal" data-via="liangkangkang" data-lang="en">Tweet</a></div></li>
							<li><div class="twitter-follow"><a href="https://twitter.com/liangkangkang" class="twitter-follow-button" data-show-count="false" data-lang="en"></a></div></li>
						</ul>
					</div>
					<div class="comment">
					


  <div id="disqus_thread"></div>
<script type="text/javascript">
    
    var disqus_developer = 1;
    var disqus_shortname = 'jekyllbootstrap'; // required: replace example with your forum shortname
    
    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Liangkangkang.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Liangkangkang</span></a>




					</div>
				</div><!-- misc-content -->
			</div><!-- bd -->
			<footer class="unit-foot">
				<div class="unit-inner unit-foot-inner">
					<nav class="pagination">
						<ul>
							
							<li class="prev"><a class="internal" rel="prev"  href="/tools/2016/10/21/out-of-wall" title="View Out Of Wall">&laquo; Out Of Wall</a></li>
							
							
							<li class="pipe"> | </li>
							
							
							<li class="next"><a class="internal" rel="next"  href="/big-data/2016/10/24/Spark" title="View Spark">Spark &raquo;</a></li>
							
						</ul>
					</nav>
					<p class="gotop">
						<a href="#page">Back to Top</a>
					</p>
				</div>
			</footer>

		</div><!-- content -->
	</div><!-- unit-inner -->
</article>


				</div>
			</div><!-- unit-inner -->
		</div><!-- unit-body -->
	</div><!-- body -->
	<footer class="the-footer">
		<div class="unit-foot">
			<div class="unit-inner unit-foot-inner">
				<div class="misc vcard">
					<h4>about</h4>
					<ul>
						<li class="contact"><address><span class="author fn n">kangkangliang</span> - <span class="fn email">lkkforworld@gmail.com</span></address></li>
						<li class="github"><a href="http://github.com/lkkandsyf/" rel="me">github.com/lkkandsyf</a></li>
						<li class="twitter"><a href="http://twitter.com/liangkangkang/" rel="me">twitter.com/liangkangkang</a></li>
						<li class="rss"><a href="http://feeds.feedburner.com/">Subscribe to RSS Feed</a></li>
					</ul>
				</div><!-- misc -->
			</div><!-- unit-foot-inner -->
		</div><!-- unit-foot -->
	</footer>
</div><!-- page -->
<script>
	(function(d, s) {
		var js, fjs = d.getElementsByTagName(s)[0], load = function(url, id) {
		if (d.getElementById(id)) {return;}
		js = d.createElement(s); js.src = url; js.id = id;
		fjs.parentNode.insertBefore(js, fjs);
		};
	load('//platform.twitter.com/widgets.js', 'tweetjs');
	// load('https://apis.google.com/js/plusone.js', 'gplus1js'); // Checkout http://j.mp/ApDgMr for usage html for this is <div class="g-plusone" data-size="medium"></div>
	// load('//connect.facebook.net/en_US/all.js#xfbml=1', 'fbjssdk'); // Checkout http://j.mp/wZw2xR for using open graph protorol html for this is <div class="fb-like" data-href="/docker/2016/10/24/Docker" data-send="false" data-layout="button_count" data-width="450" data-show-faces="false" data-font="verdana"></div>
	}(document, 'script'));
</script>
<script>
/*! A fix for the iOS orientationchange zoom bug.Script by @scottjehl, rebound by @wilto. MIT License.*/
(function(j){var i=j.document;if(!i.querySelectorAll){return}var l=i.querySelectorAll("meta[name=viewport]")[0],a=l&&l.getAttribute("content"),h=a+", maximum-scale=1.0",d=a+", maximum-scale=10.0",g=true,c=j.orientation,k=0;if(!l){return}function f(){l.setAttribute("content",d);g=true}function b(){l.setAttribute("content",h);g=false}function e(m){c=Math.abs(j.orientation);k=Math.abs(m.gamma);if(k>8&&c===0){if(g){b()}}else{if(!g){f()}}}j.addEventListener("orientationchange",f,false);j.addEventListener("deviceorientation",e,false)})(this);
</script>

  



</body>
</html>

