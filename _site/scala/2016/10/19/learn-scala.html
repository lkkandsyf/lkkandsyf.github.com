

<!DOCTYPE html>
<!--[if lt IE 7]> <html class="no-js lt-ie9 lt-ie8 lt-ie7 ie" lang="en"> <![endif]-->
<!--[if IE 7]>    <html class="no-js lt-ie9 lt-ie8 ie" lang="en"> <![endif]-->
<!--[if IE 8]>    <html class="no-js lt-ie9 ie" lang="en"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"> <!--<![endif]-->
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width,initial-scale=1">
	<title>Learn Scala</title>
	<meta name="author" content="kangkangliang">
	<link href='/assets/themes/the-program/css/style.css' rel="stylesheet" media="all">
	<link href="http://feeds.feedburner.com/" rel="alternate" title="Learn Scala" type="application/atom+xml">
	<script src="http://cdnjs.cloudflare.com/ajax/libs/modernizr/2.0.6/modernizr.min.js"></script>
</head>
<body>

<div id="page" class="hentry">
	<header class="the-header">
		<div class="unit-head">
			<div class="unit-inner unit-head-inner">
				<nav class="nav-global">
					<ul>
						<li class="logo"><a href="/">既生而为人，就要承担，安然接受人生可能发生的一切。</a></li>
						<li class="archive"><a href="/archive.html">archive</a></li>
						<li class="page"><a href="/pages.html">pages</a></li>
						<li class="category"><a href="/categories.html">categories</a></li>
						<li class="tag"><a href="/tags.html">tags</a></li>
						<li class="forkme"><div><iframe src="http://markdotto.github.com/github-buttons/github-btn.html?user=plusjade&repo=jekyll-bootstrap&type=fork&count=true"
									allowtransparency="true" frameborder="0" scrolling="0" width="95px" height="20px"></iframe></div></li>
					</ul>
				</nav>
			</div><!-- unit-inner -->
		</div><!-- unit-head -->
	</header>
	<div class="body" role="main">
		<div class="unit-body">
			<div class="unit-inner unit-body-inner">
				<div class="entry-content">
					

<article class="unit-article layout-post">
	<div class="unit-inner unit-article-inner">
		<div class="content">
			<header>
				<div class="unit-head">
					<div class="unit-inner unit-head-inner">
						<h1 class="h2 entry-title">Learn Scala</h1>
					</div><!-- unit-inner -->
				</div><!-- unit-head -->
			</header>

			<div class="bd">
				<div class="entry-content">
					
<h1 class="no_toc" id="overview">Overview</h1>
<p>这里整理自己学习scala的整个过程，以及笔记。</p>

<ul id="markdown-toc">
  <li><a href="#tools" id="markdown-toc-tools">tools</a>    <ul>
      <li><a href="#section" id="markdown-toc-section">基础</a>        <ul>
          <li><a href="#section-1" id="markdown-toc-section-1">1.变量</a></li>
          <li><a href="#section-2" id="markdown-toc-section-2">2.常用的类型</a></li>
          <li><a href="#section-3" id="markdown-toc-section-3">3.数值类型转换</a></li>
          <li><a href="#section-4" id="markdown-toc-section-4">4.操作符</a></li>
          <li><a href="#section-5" id="markdown-toc-section-5">5.函数调用和方法</a></li>
          <li><a href="#apply" id="markdown-toc-apply">6.apply方法</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#section-6" id="markdown-toc-section-6">控制结构和函数</a>    <ul>
      <li><a href="#if" id="markdown-toc-if">1.if语句也有返回值</a></li>
      <li><a href="#section-7" id="markdown-toc-section-7">2.块表达式</a>        <ul>
          <li><a href="#io" id="markdown-toc-io">3.IO</a></li>
          <li><a href="#loop" id="markdown-toc-loop">4.Loop</a></li>
          <li><a href="#for" id="markdown-toc-for">5.for</a></li>
          <li><a href="#section-8" id="markdown-toc-section-8">6.函数式编程</a></li>
          <li><a href="#section-9" id="markdown-toc-section-9">7.懒值</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#section-10" id="markdown-toc-section-10">疑惑</a>    <ul>
      <li><a href="#match" id="markdown-toc-match">7.match</a></li>
      <li><a href="#section-11" id="markdown-toc-section-11">数组-映射-元组-类-对象</a>        <ul>
          <li><a href="#section-12" id="markdown-toc-section-12">1.数组</a></li>
          <li><a href="#section-13" id="markdown-toc-section-13">2.映射</a></li>
          <li><a href="#section-14" id="markdown-toc-section-14">3.元组</a></li>
          <li><a href="#list" id="markdown-toc-list">4.List</a></li>
          <li><a href="#set" id="markdown-toc-set">5.Set</a></li>
          <li><a href="#section-15" id="markdown-toc-section-15">6.类</a></li>
          <li><a href="#section-16" id="markdown-toc-section-16">7.对象</a></li>
          <li><a href="#section-17" id="markdown-toc-section-17">8.函数</a></li>
        </ul>
      </li>
      <li><a href="#scala-api-download" id="markdown-toc-scala-api-download">Scala API download</a></li>
    </ul>
  </li>
</ul>

<h2 id="tools">tools</h2>

<p><a href="https://lkkandsyf.github.io/scala/2016/11/05/sbt-debug">sbt</a></p>

<p>learn twitter scala course</p>

<p><a href="http://twitter.github.io/effectivescala/index-cn.html">effective scala</a>
<a href="http://twitter.github.io/scala_school/zh_cn/index.html">scala course</a></p>
<h3 id="section">基础</h3>

<h4 id="section-1">1.变量</h4>
<div class="highlighter-rouge"><pre class="highlight"><code>val 标志符：声明变量；如，val result = 1
var 标志符：声明变量；
</code></pre>
</div>

<ul>
  <li>类型推断：变量的类型由scala根据初始化变量的表达式推断出来，<code class="highlighter-rouge">鼓励使用val</code>；<strong>note:声明变量时不做初始化会报错</strong></li>
  <li>明确类型：scala的<code class="highlighter-rouge">变量或函数的类型总是写在变量或函数的后面</code>.</li>
</ul>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">val</span> <span class="n">a</span><span class="k">:</span><span class="kt">Int</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">val</span> <span class="n">str</span><span class="k">:</span><span class="kt">String</span> <span class="o">=</span> <span class="s">"hello world"</span>
</code></pre>
</div>

<h4 id="section-2">2.常用的类型</h4>

<p>Scala支持<code class="highlighter-rouge">7中数值类型和1中Boolean类型</code></p>

<div class="highlighter-rouge"><pre class="highlight"><code> Byte/Char/Short/Int/Float/Double
 Boolean
</code></pre>
</div>

<font color="red">note:</font>
<p><code class="highlighter-rouge">所有这些类型都是类</code>，Scala并<code class="highlighter-rouge">未区分基本类型和引用类型</code>。如，可以调用123.toString方法。</p>

<h4 id="section-3">3.数值类型转换</h4>

<p>Scala中使用方法，而<code class="highlighter-rouge">非强制类型转换</code>来做<code class="highlighter-rouge">数值类型之间的转换</code>，如：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>scala&gt; 123.123.toInt
res6: Int = 123
scala&gt; 123.123.toChar
res7: Char = {
scala&gt; 123.123.toLong
res8: Long = 123
scala&gt; "123.123".toDouble
res9: Double = 123.123
</code></pre>
</div>

<h4 id="section-4">4.操作符</h4>

<p>Scala支持Java绝大多数操作符，不过<code class="highlighter-rouge">所有的操作符都是方法</code>，如：a+b是a+(b)的缩写。即：a方法b是a.方法(b)的缩写，两种写法<code class="highlighter-rouge">可以互换</code>。</p>

<font color="red">note:</font>
<p>Scala<code class="highlighter-rouge">不支持++和--操作符</code>。</p>

<h4 id="section-5">5.函数调用和方法</h4>

<p>常用的数学函数包括在scala.math包中。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>import scala.math._			// Scala中，字符_是通配符，类似Java的*
</code></pre>
</div>

<p>另外，以scala开头的包，在引入或者使用时可以<code class="highlighter-rouge">省略scala</code></p>

<div class="highlighter-rouge"><pre class="highlight"><code>import math._
math.sqrt(2)
</code></pre>
</div>

<font color="red">note:</font>
<p>Scala<code class="highlighter-rouge">没有静态方法</code>。</p>

<p><code class="highlighter-rouge">不带参数的方法在调用时可以省略括号</code>，如：在调用toStrig后面的括号是可以省略的。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>"Helloworld".toString
</code></pre>
</div>

<h4 id="apply">6.apply方法</h4>

<p>在Scala中通常使用类似函数调用的形式来访问数组、链表等的元素。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>scala&gt;"helloworld"(0)
res0:Char = h
</code></pre>
</div>

<p>上述调用中，”helloworld”(0)是”helloworld”.apply(0)的调用，其中apply方法是StringOps类中的方法。</p>

<h2 id="section-6">控制结构和函数</h2>

<h4 id="if">1.if语句也有返回值</h4>

<p>if语句成为<code class="highlighter-rouge">条件表达式</code></p>

<div class="highlighter-rouge"><pre class="highlight"><code>scala&gt;val x = 1
x :Int = 1
scala&gt;val y = if(x &gt; 1) 1 else -1
y : Int = 1
</code></pre>
</div>

<p>条件表达式的结构：<code class="highlighter-rouge">if（判断条件） 值1 else 值2</code>；类似于Java中<code class="highlighter-rouge">三目运算符</code>，但是，<code class="highlighter-rouge">Scala不支持三目运算符</code>，该条件表达式<code class="highlighter-rouge">可以用来初始化val常量</code>.</p>

<font color="red">note:</font>
<p>Scala<code class="highlighter-rouge">中每个表达式都会有返回值</code>。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>scala&gt;if (x &gt; 4) 1
res0 AnyVal =()
</code></pre>
</div>

<p>表达式返回了(),其中()表示Uint类，表示没有值，可以看做Java中<code class="highlighter-rouge">void类型</code>。</p>

<h3 id="section-7">2.块表达式</h3>
<p>块表达式：Scala中用{}括起来一系列表达式，其中{}括起来的部分<code class="highlighter-rouge">叫做块表达式</code>，块表达式的值是<code class="highlighter-rouge">块中最后一个表达式的值</code></p>

<div class="highlighter-rouge"><pre class="highlight"><code>scala&gt;{
	1+2
	2+3
}
res1 Int = 5
</code></pre>
</div>

<p>可以使用块表达式为变量赋值</p>

<div class="highlighter-rouge"><pre class="highlight"><code>scala&gt;val x = 1;val x0 = 0;val y = 1;val y0= 0
x:Int = 1
x0:Int = 0
y:Int = 1
y0:Int = 0

scala&gt;val distance = {val dx = x - x0
	val dy = y - y0
	math.sqrt(dx*dx+dy*dy)
}
distance:Double = 1.41421
</code></pre>
</div>

<p>变量distance使用块表达式来赋值，其值为块中最后一个表达式的值</p>

<font color="red">note:</font>
<p>Scala中赋值语句的<code class="highlighter-rouge">返回值为Uint</code>，也可记做：Scala中赋值语句是没有返回值的。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>scala&gt; val a = 1
a: Int = 1

scala&gt; val b = 2
b: Int = 2

scala&gt; a = b =4
&lt;console&gt;:13: error: reassignment to val
	a = b =4
</code></pre>
</div>

<p>a = b = 4；这种赋值形式在Scala中<code class="highlighter-rouge">不支持</code>，因为在赋值语句中Scala中<code class="highlighter-rouge">无返回值</code>，所以<code class="highlighter-rouge">+=，-=，*=,/=等赋值操作符都是无返回值</code>的.</p>

<h4 id="io">3.IO</h4>

<ul>
  <li>
    <p>输入:常用的包括readline从控制台<code class="highlighter-rouge">读取一行输入</code>，另外，readLine还可以<code class="highlighter-rouge">带有字符串提示</code></p>

    <p>scala&gt; val name = readLine(“input your name:”)
 inpput your name:</p>
  </li>
</ul>

<p>readInt,readByte,readDouble,readShort,readLong,readFloat,readBoolean,readChar分别用于读取各自类型的值。</p>
<ul>
  <li>输出:print(content),println(content),printf();其中println带换行，printf支持C风格的字符串输出。
    <h4 id="loop">4.Loop</h4>
    <p>Scala支持Java相同的while和do循环</p>

    <p>scala&gt;var x = 2
 x:Int = 2
 scala&gt;while(x &gt; 0){		// 这里必须写x&gt;0 写成一个独立的x，程序会报错布尔和整形的区别
     println(x)
     x -= 1
 }
 2
 1
 scala&gt; do{
     println(x)
     x -= 1
 }while(x &gt; 0)
 0</p>
  </li>
</ul>

<h4 id="for">5.for</h4>
<p>Scala的for循环结构:（for循环中，变量前面<code class="highlighter-rouge">不带var或val标志符</code>）</p>

<div class="highlighter-rouge"><pre class="highlight"><code>for(变量 &lt;- 表达式){	// 让变量遍历表达式的所有的值
	// operations
}
</code></pre>
</div>

<p>如：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>scala&gt; for(i &lt;- 0 to 3)
     | println(i)
     0
     1
     2
     3

 scala&gt; val str = "hello world"
 str: String = hello world
 scala&gt; for(c &lt;- str)
      | println(c)
      h
      e
      l
      l
      o
      w
      o
      r
      l
      d

scala&gt; for(i &lt;- 0 until str.length)
     | println(str(i))
     h
     e
     l
     l
     o

     w
     o
     r
	 l
	 d
</code></pre>
</div>

<p><code class="highlighter-rouge">for的高级用法</code></p>

<p><strong>可以在for loop括号里面同事包含<code class="highlighter-rouge">多组"变量&lt;- 表达式"结构</code>，组之间用<code class="highlighter-rouge">分号</code>隔开</strong></p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code>	<span class="k">for</span><span class="o">(</span><span class="n">i</span> <span class="k">&lt;-</span> <span class="mi">1</span> <span class="n">until</span> <span class="mi">3</span><span class="o">;</span> <span class="n">j</span> <span class="k">&lt;-</span> <span class="n">until</span> <span class="mi">3</span><span class="o">){</span>
		<span class="n">println</span><span class="o">(</span><span class="n">i</span><span class="o">*</span><span class="n">j</span><span class="o">)</span>
	<span class="o">}</span>
	<span class="c1">//for loop的这种结构类似Java中嵌套环结构,也可以用
</span>
	<span class="k">for</span><span class="o">{</span><span class="n">i</span> <span class="k">&lt;-</span> <span class="mi">1</span> <span class="n">until</span> <span class="mi">3</span>		<span class="c1">// 使用大括号，使用换行来分割组
</span>		<span class="n">j</span> <span class="k">&lt;-</span> <span class="n">until</span> <span class="mi">3</span> <span class="o">}{</span>
			<span class="n">println</span><span class="o">(</span><span class="n">i</span><span class="o">*</span><span class="n">j</span><span class="o">)</span>
	<span class="o">}</span>
</code></pre>
</div>

<p><strong>可以为嵌套循环通过if表达式添加条件</strong></p>

<div class="highlighter-rouge"><pre class="highlight"><code> scala&gt; for (i &lt;- -1 until 3; j &lt;- -1 until 3 if i != j) {
 	     | printf("i = %d,j = %d\n",i,j)
 	     |
		 }
 i = -1,j = 0
 i = -1,j = 1
 i = -1,j = 2
 i = 0,j = -1
 i = 0,j = 1
 i = 0,j = 2
 i = 1,j = -1
 i = 1,j = 0
 i = 1,j = 2
 i = 2,j = -1
 i = 2,j = 0
 i = 2,j = 1

 scala&gt; for (i &lt;- -1 until 3; j &lt;- -1 until 3 if i != j) {
 	     | printf("i = %d,j = %d\n",i,j)
 	     |
		}
 i = -1,j = 0
 i = -1,j = 1
 i = -1,j = 2
 i = 0,j = -1
 i = 0,j = 1
 i = 0,j = 2
 i = 1,j = -1
 i = 1,j = 0
 i = 1,j = 2
 i = 2,j = -1
 i = 2,j = 0
 i = 2,j = 1

 scala&gt; for (i &lt;- -1 to 3; j &lt;- -1 to 3 if i != j) {
 	     | printf("i = %d,j = %d\n",i,j)
         |
	 }
 i = -1,j = 0
 i = -1,j = 1
 i = -1,j = 2
 i = -1,j = 3
 i = 0,j = -1
 i = 0,j = 1
 i = 0,j = 2
 i = 0,j = 3
 i = 1,j = -1
 i = 1,j = 0
 i = 1,j = 2
 i = 1,j = 3
 i = 2,j = -1
 i = 2,j = 0
 i = 2,j = 1
 i = 2,j = 3
 i = 3,j = -1
 i = 3,j = 0
 i = 3,j = 1
 i = 3,j = 2
</code></pre>
</div>

<p><code class="highlighter-rouge">if表达式是否添加括号</code>，结果无变化</p>

<p>until返回一个不包含上界的区间1 until 返回(1,2),to方法返回一个包含上界的区间 1 to 3返回(1,2,3)</p>

<p><strong>for 推导式</strong></p>

<p>如果for loop以yield开始，for loop会构造一个<code class="highlighter-rouge">集合</code>，保存到集合中。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>scala&gt; for(i &lt;- 1 to 3; j &lt;- 1 to 3 if(i != j)) yield i*10+j
res6: scala.collection.immutable.IndexedSeq[Int] = Vector(12, 13, 21, 23, 31, 32)

scala&gt; for(c &lt;- "hello") yield(c.toInt - 32).toChar
res7: String = HELLO
</code></pre>
</div>

<h4 id="section-8">6.函数式编程</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>def 函数名(参数1:类型1，参数2::类型，...);返回值类型 = {
	// 函数体
}

scala&gt;def isNeg(x:Int) = if(x&gt;0) true else false
isNeg:(x:Int)Boolean
scala&gt;isNeg(8)
res3 Boolean = ture
scala&gt;isNeg(-1)
res4 Boolean = false
scala&gt;def f(x:Int):Int = if(n==0 || n==1) 1 else f(n-1)*n
f:(n:Int)Int
</code></pre>
</div>

<font color="red">note:</font>
<p>对于有<code class="highlighter-rouge">返回值的函数</code>，不能<code class="highlighter-rouge">省略等号</code>；对于递归函数，不能<code class="highlighter-rouge">省略函数返回类型</code>。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>scala&gt;def noReturnVal(name:String){
	!	println("hello world")
	!	}
noReturnVal:(name:Strint)Uint
</code></pre>
</div>

<font color="red">note:</font>
<p><code class="highlighter-rouge">无返回值的函数定义</code>可以<code class="highlighter-rouge">省略等号</code>；无返回值的函数返回类型是<code class="highlighter-rouge">Uint</code>.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>scala&gt;def format(content:String,start:String="&lt;&lt;",end:String="&gt;&gt;") =
	!	start + content + end
format:(content:String,start:String="&lt;&lt;",end:String="&gt;&gt;")String
</code></pre>
</div>

<p>带<code class="highlighter-rouge">默认函数的声明</code>，与<code class="highlighter-rouge">Java中默认值的方法很类似</code>.</p>

<p>带名参数—–在函数调用时通过<code class="highlighter-rouge">明确指明参数与其对应值</code>.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>scala&gt;format("lkk")
res5:String = &lt;&lt;lkk&gt;&gt;
scala&gt;format(start="%%",end="$$",content="lkk")
res6:String = %%lkk$$
</code></pre>
</div>

<p>第一个函数调用为<code class="highlighter-rouge">普通调用</code>，第二个函数调用为<code class="highlighter-rouge">带参数调用</code>。</p>

<p>长度可变的参数列表，通过在函数的形参列表最后一个参数的类型后，添加<strong>星号</strong>，来定义一个接受任意多个参数的函数。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>scala&gt;def Two(owner:String,guests:String*){
	for(guest &lt;- guests){
		println(owner + " lkk welcome to learn scala" + guest)
	}
}
Two:(owner:String,guests:String*)Uint

scala&gt;Two("AAA","BBB","CCC")
AAA lkk welcome to learn scala  BBB
AAA lkk welcome to learn scala  CCC
</code></pre>
</div>

<p>如上面的Two函数，没有<code class="highlighter-rouge">返回值</code>的函数叫做过程，<code class="highlighter-rouge">过程在定义的时候，参数列表之后无等号</code>。</p>

<h4 id="section-9">7.懒值</h4>

<p>当val被声明为<code class="highlighter-rouge">lazy</code>时,变量的初始化将被<code class="highlighter-rouge">延迟</code>，直到我们<code class="highlighter-rouge">首次对变量取值</code></p>

<div class="highlighter-rouge"><pre class="highlight"><code>lazy val fileContent = scala.io.Source.fromFile("filename").mkString
</code></pre>
</div>

<p>只有当我们读取<code class="highlighter-rouge">fileContent</code>值的时候，fileContent才会通过读取文件来进行初始化。若我们一直未<code class="highlighter-rouge">读取fileContent的值</code>，这个文件不会被读取。</p>

<font color="red">note:</font>
<ul>
  <li>Scala<code class="highlighter-rouge">不支持switch</code>语句，但是Scala有<code class="highlighter-rouge">强大的模式匹配机制</code>。</li>
  <li>Scala<code class="highlighter-rouge">不支持break语句和continue</code>语句。</li>
  <li>Scala<code class="highlighter-rouge">不支持break语句和continue</code>语句。</li>
  <li>Scala<code class="highlighter-rouge">没有受检异常-----无需声明函数或方法可能会跑出某种异常</code>。</li>
  <li>Scala<code class="highlighter-rouge">中将没有返回值的函数</code>，叫做过程,过程在定义的时候，<code class="highlighter-rouge">参数列表之后无等号</code>。</li>
</ul>

<h2 id="section-10">疑惑</h2>
<ul>
  <li>方法的定义体出现的等号(=)之后，为什么使用=？,而不像Java那样，使用的是{}来表示方法体呢？
 scala使用[]来表示参数类型，Java用的是&lt;&gt;,并且不允许在标识符中使用[].
 A:1)避免歧义是原因之一，当你在代码中省略<code class="highlighter-rouge">分号</code>时，Scala能够推断出来。在大多数的时候，Scala能够推导出方法的返回类型。假设方法不接受任何参数，你还可以在方法定义中省略参数列表。</li>
</ul>

<p>2)使用=也强调了函数式编程的一个准则：值和函数是高度对齐的概念。函数可以作为参数传递给其他函数，也能够返回函数，还能够赋给某一个变量，这与对象的行为是一致的。</p>

<p>最后说一下，假设方法体中<code class="highlighter-rouge">仅包含一个表达式</code>，那么Scala允许你省略花括号，所以说，使用=能够避免可能的解析歧义。</p>

<h4 id="match">7.match</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>scala&gt;def level(s:Int) = s match{
	case n if n &gt;= 90 =&gt; "good"
	case n if n &gt;= 80 =&gt; "good2"
	case n if n &gt;= 70 =&gt; "good3"
	case n if n &gt;= 60 =&gt; "good3"
	case _ =&gt; "bad"
}
scala&gt; levle(51)
res2:String = bad

scala&gt; levle(91)
res2:String = good

scala&gt; levle(81)
res2:String = good2
</code></pre>
</div>

<p>可以看到，模式匹配可以使用swith相同的功能。但是switch需要使用break明确通知终止之后的判断不同，scala中match case是<code class="highlighter-rouge">默认break</code>的,只要其中一个case语句匹配，就会终止后的所有比较。且对应的case语句的表达式的值将作为整个match case表达式的值返回。</p>

<p>Scala中的模式匹配还有类型匹配，数据抽取，谓词判断等其它有用的功能。</p>

<h3 id="section-11">数组-映射-元组-类-对象</h3>

<h4 id="section-12">1.数组</h4>

<p><strong>定长数组</strong></p>

<p>声明数组的两种形式</p>

<p>1)<strong>声明<code class="highlighter-rouge">指定长度</code>的数组val 数组名 = new Array<a href="数组长度">类型</a></strong></p>

<div class="highlighter-rouge"><pre class="highlight"><code>scala&gt; val arr = new Array[String](5)
arr: Array[String] = Array(null, null, null, null, null)

scala&gt; val intArr = new Array[Int](4)
intArr: Array[Int] = Array(0, 0, 0, 0)
</code></pre>
</div>

<p>2)提供数组<code class="highlighter-rouge">初始值</code>的数组，<code class="highlighter-rouge">无需new</code>关键字</p>

<div class="highlighter-rouge"><pre class="highlight"><code>scala&gt; val charArr = Array('a','b','c')
charArr: Array[Char] = Array(a, b, c)
</code></pre>
</div>

<p>Scala声明数组时，需要<code class="highlighter-rouge">带有Array</code>类名，且使用()来<code class="highlighter-rouge">指明长度</code>或<code class="highlighter-rouge">提供初始值序列</code>.在JVM中，Scala的Array以Java数组的方式实现。如arr在JVM的类型对应java.lng.String[],charArr对应char[].</p>

<p><strong>变长数组</strong></p>

<div class="highlighter-rouge"><pre class="highlight"><code>scala&gt;import scala.collection.mutable.ArrayBuffer

scala&gt; val b = ArrayBuffer[Int]()
b: scala.collection.mutable.ArrayBuffer[Int] = ArrayBuffer()

scala&gt;  b += 1
res1: b.type = ArrayBuffer(1)

scala&gt; b += (1,2,3,4,5)
res2: b.type = ArrayBuffer(1, 1, 2, 3, 4, 5)

scala&gt; b.trimEnd(5)

scala&gt; b
res7: scala.collection.mutable.ArrayBuffer[Int] = ArrayBuffer(1, 1, 2)
scala&gt; b.toArray
res8: Array[Int] = Array(1, 1, 2)

scala&gt; b
res9: scala.collection.mutable.ArrayBuffer[Int] = ArrayBuffer(1, 1, 2)
</code></pre>
</div>

<p>ArrayBuffer，全称：scala.collection.mutable.ArrayBuffer,类似与Java中的ArrayList和C++中的vector，是长度可变数组类型的结构，<code class="highlighter-rouge">称为数组缓冲</code></p>

<p>通过：val name = ArrayBuffer[类型]()来声明，声明<code class="highlighter-rouge">ArrayBuffer</code>时要指明<code class="highlighter-rouge">类型</code>。</p>

<p>通过+=操作操作来<code class="highlighter-rouge">添加元素或序列</code>，++=操作符来<code class="highlighter-rouge">拼接数组</code>。在ArrayBuffer的<code class="highlighter-rouge">尾端添加或删除元素是一个高效的操作</code>,ArrayBuffer还支持在<code class="highlighter-rouge">指定位置插入，删除元素</code>。</p>

<p>ArrayBuffer到数组的转换:toArray方法</p>

<p><strong>数组遍历</strong></p>

<div class="highlighter-rouge"><pre class="highlight"><code>用for loop
scala&gt;for(i &lt;- until array.length)
		println(i)
scala&gt;for(i &lt;- b)
		println(i)
指定遍历数组的步长---通过until(上界，步长)
scala&gt; val intArr = Array(1,2,3,4,5,6,7,8,9)
intArr: Array[Int] = Array(1, 2, 3, 4, 5, 6, 7, 8, 9)
scala&gt; for(i &lt;- 0 until(intArr.length,2))
     | println(i)
     0
     2
     4
     6
     8
scala&gt; for(i &lt;- 0 until(intArr.length,2))
     | println(intArr(i))
     1
     3
     5
     7
     9
通过reverse函数逆序遍历数组
scala&gt; for(i &lt;- (0 until intArr.length).reverse)
     | println(intArr(i))
     9
     8
     7
     6
     5
     4
     3
     2
     1
</code></pre>
</div>

<p><strong>for loop get yield</strong></p>

<p>可以通过for loop + yield来获得<code class="highlighter-rouge">新的数组或ArrayBuffer</code>。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>scala&gt; val intArr = Array(1,2,3,4)
intArr: Array[Int] = Array(1, 2, 3, 4)

scala&gt; for(i &lt;- intArr) yield{
		| i*2
		|
}
res0: Array[Int] = Array(2, 4, 6, 8)

scala&gt; for(b &lt;- intArr) yield -b
res2: Array[Int] = Array(-1, -2, -3, -4)
</code></pre>
</div>

<p>通过for+yield操作数组或者ArrayBuffer之后将得到新的数组或ArrayBuffer。</p>

<p><strong>操作数组/数组缓冲常用函数</strong></p>

<div class="highlighter-rouge"><pre class="highlight"><code>scala&gt; val intArr = Array(1,2,3,4)
intArr: Array[Int] = Array(1, 2, 3, 4)

scala&gt; intArr.sum
res0: Int = 10

scala&gt; intArr.max
res1: Int = 4

scala&gt; intArr.min
res2: Int = 1

scala&gt; intArr.sorted
res4: Array[Int] = Array(1, 2, 3, 4)
</code></pre>
</div>

<p>求和，求最小值，最大值，数组排序.通过sorted函数对数组或者ArrayBuffer排序时，返回的是<code class="highlighter-rouge">一个新的数组或ArrayBuffer</code>，原有的<code class="highlighter-rouge">不变</code>。</p>

<p><code class="highlighter-rouge">可以直接对数组调用排序算法</code>，但是不能对<code class="highlighter-rouge">ArrayBuffer排序</code>。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>scala&gt; util.Sorting.quickSort(intArr)

scala&gt; intArr
res7: Array[Int] = Array(1, 2, 3, 4)
</code></pre>
</div>

<p><strong>quickSort是直接修改原来的数组，而sorted方法是返回新数组。</strong></p>

<p><strong>多维数组</strong></p>

<p>Scala中的多维数组和同Java中一样，<code class="highlighter-rouge">多维数组都是数组的数组</code>。</p>

<p>1)通过Array.ofDim[类型](维度1，维度2，维度3,….)来声明<code class="highlighter-rouge">多维数组</code></p>

<div class="highlighter-rouge"><pre class="highlight"><code>scala&gt; val mulDimArr = Array.ofDim[Double](2,3)
mulDimArr: Array[Array[Double]] = Array(Array(0.0, 0.0, 0.0), Array(0.0, 0.0, 0.0))
</code></pre>
</div>

<p>从二维数组的初始化，我们看到，多维数组在Scala中也是数组的数组。</p>

<p>2)通过Array[Array][Int](维度1)来声明数组，可以声明<code class="highlighter-rouge">不规则数组</code></p>

<div class="highlighter-rouge"><pre class="highlight"><code>scala&gt; val difLenMulArr = new Array[Array[Int]](3)
difLenMulArr: Array[Array[Int]] = Array(null, null, null)

scala&gt; for (i &lt;- 1 to difLenMulArr.length){
		| difLenMulArr(i-1) = new Array[Int](i)
			|
}

scala&gt; difLenMulArr
res9: Array[Array[Int]] = Array(Array(0), Array(0, 0), Array(0, 0, 0))
</code></pre>
</div>

<p>多维数组是数组的数组，按照这种性质来声明多维数组，如例子中的二维数组，声明时，需要指定最外围的数组大小。</p>

<p><strong>note:可以通过scala.collection.JavaConversions包中隐式转换方法来实现Scala容器类与Java中类的转换</strong></p>

<h4 id="section-13">2.映射</h4>

<p><strong>映射构造</strong></p>

<p><code class="highlighter-rouge">对偶</code>，即名值对，可以通过-&gt;操作符号来定义<code class="highlighter-rouge">对偶</code>，<strong>名-&gt;值</strong>运算的结构是(名，值)</p>

<div class="highlighter-rouge"><pre class="highlight"><code>scala&gt; "aaa" -&gt; 1
res10: (String, Int) = (aaa,1)

scala&gt; ("bbb" -&gt; 2)
res11: (String, Int) = (bbb,2)
</code></pre>
</div>

<p>也可以<code class="highlighter-rouge">声明对偶形式的变量</code></p>

<div class="highlighter-rouge"><pre class="highlight"><code>scala&gt; val (name,age) = ("liangkangkang",26)
name: String = liangkangkang
age: Int = 26
</code></pre>
</div>

<p><code class="highlighter-rouge">映射</code>是由对偶构成的，<strong>映射是对偶的集合</strong>.</p>

<p>1) 声明<code class="highlighter-rouge">不可变</code>映射,直接用<code class="highlighter-rouge">Map</code>来声明时，默认是不可变映射类型。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>scala&gt; val charIntMap = Map('a'-&gt;97,'b'-&gt;98)
charIntMap: scala.collection.immutable.Map[Char,Int] = Map(a -&gt; 97, b -&gt; 98)

scala&gt; charIntMap('a')
res12: Int = 97
</code></pre>
</div>

<p><strong>注意:不可变映射维持元素的插入顺序</strong></p>

<p>2)声明<code class="highlighter-rouge">可变</code>对象(scala.collection.mutable.Map)</p>

<div class="highlighter-rouge"><pre class="highlight"><code>scala&gt; val charToIntMap = collection.mutable.Map('a'-&gt;96,'b'-&gt;97)
charToIntMap: scala.collection.mutable.Map[Char,Int] = Map(b -&gt; 97, a -&gt; 96)
</code></pre>
</div>

<p><strong>注意：放入<code class="highlighter-rouge">可变映射中的值</code>并未按照<code class="highlighter-rouge">放入顺序</code>来排序</strong></p>

<p>通过for loop来修改<code class="highlighter-rouge">可变Map</code>中的值</p>

<div class="highlighter-rouge"><pre class="highlight"><code>scala&gt; for ((k,v) &lt;- charToIntMap){
     | charToIntMap(k) = v + 1
      |
	}
scala&gt; charToIntMap
res14: scala.collection.mutable.Map[Char,Int] = Map(b -&gt; 98, a -&gt; 97)
</code></pre>
</div>

<p><strong>注意:映射可变，不可变指的是<code class="highlighter-rouge">整个映射是否可变</code>，包扩<code class="highlighter-rouge">元素值，映射中元素的个数，元素次序等</code></strong></p>

<p>3)声明空映射</p>

<p>直接通过new Map[类型1，类型2]()来定义映射会<code class="highlighter-rouge">报错</code>，因为Map是抽象的，无法实例化。</p>

<p>定义空映射时，需要指定映射的<code class="highlighter-rouge">实现类</code>，通过<code class="highlighter-rouge">new</code>来定义</p>

<div class="highlighter-rouge"><pre class="highlight"><code>scala&gt; val map = new scala.collection.immutable.HashMap[Int,Char]()
map: scala.collection.immutable.HashMap[Int,Char] = Map()

scala&gt; val map = new collection.mutable.HashMap[Int,Char]()
map: scala.collection.mutable.HashMap[Int,Char] = Map()
</code></pre>
</div>

<p>从上面的immutable和mutable可以看出来，两者是不同的。</p>

<p><strong>映射常用操作</strong></p>

<p>1)判断映射中<code class="highlighter-rouge">是否含有某个键</code>:map.contain(键值)</p>

<div class="highlighter-rouge"><pre class="highlight"><code>scala&gt; charToIntMap.contains('c')
res15: Boolean = false

scala&gt; charToIntMap.contains('a')
res16: Boolean = true
</code></pre>
</div>

<p>2)使用+=向<code class="highlighter-rouge">可变</code>映射中<code class="highlighter-rouge">添加元素或拼接映射</code></p>

<div class="highlighter-rouge"><pre class="highlight"><code>scala&gt; map += (1-&gt;'a')
res17: map.type = Map(1 -&gt; a)

scala&gt; map
res18: scala.collection.mutable.HashMap[Int,Char] = Map(1 -&gt; a)

scala&gt; map += (2-&gt;'b',3-&gt;'d')
res19: map.type = Map(2 -&gt; b, 1 -&gt; a, 3 -&gt; d)
</code></pre>
</div>

<p>3)使用-=来<code class="highlighter-rouge">移除可变</code>映射中的键及对应元素</p>

<div class="highlighter-rouge"><pre class="highlight"><code>scala&gt; map -= 2
res21: map.type = Map(1 -&gt; a, 3 -&gt; d)
</code></pre>
</div>

<p>4)不可变映射可通过+操作符返回一个<code class="highlighter-rouge">新的不可变映射</code>；不可变映射可通过-操作符返回一个<code class="highlighter-rouge">新的不可变映射</code></p>

<div class="highlighter-rouge"><pre class="highlight"><code>scala&gt; val map = Map(1-&gt;1,2-&gt;4,3-&gt;9)
map: scala.collection.immutable.Map[Int,Int] = Map(1 -&gt; 1, 2 -&gt; 4, 3 -&gt; 9)

scala&gt; val mapSum = map + (4-&gt;16,5-&gt;25)
mapSum: scala.collection.immutable.Map[Int,Int] = Map(5 -&gt; 25, 1 -&gt; 1, 2 -&gt; 4, 3 -&gt; 9, 4 -&gt; 16)

scala&gt; val mapDif = mapSum - 1
mapDif: scala.collection.immutable.Map[Int,Int] = Map(5 -&gt; 25, 2 -&gt; 4, 3 -&gt; 9, 4 -&gt; 16)
</code></pre>
</div>

<p>5)映射遍历</p>

<div class="highlighter-rouge"><pre class="highlight"><code>scala&gt; mapDif
res25: scala.collection.immutable.Map[Int,Int] = Map(5 -&gt; 25, 2 -&gt; 4, 3 -&gt; 9, 4 -&gt; 16)

scala&gt; for((base,square) &lt;- mapDif){
		| println(base + "*" + base + " = " + square)
		|
}
5*5 = 25
2*2 = 4
3*3 = 9
4*4 = 16
</code></pre>
</div>

<p>6)获取映射的键集合keySet和值集合</p>

<div class="highlighter-rouge"><pre class="highlight"><code>scala&gt; mapSum
res27: scala.collection.immutable.Map[Int,Int] = Map(5 -&gt; 25, 1 -&gt; 1, 2 -&gt; 4, 3 -&gt; 9, 4 -&gt; 16)
scala&gt; mapSum.keySet
res28: scala.collection.immutable.Set[Int] = Set(5, 1, 2, 3, 4)
scala&gt; for(squ &lt;- mapSum.values)
     | {println(squ)}
     25
     1
     4
     9
     16
</code></pre>
</div>

<p>通过映射的keySet方法可以活动映射的由键值构成集合，通过values方法可以过得映射值的Interable对象，应用于循环中，Scala的keySet/valus方法类似于Java中的映射方法。</p>

<p>7)Scala的映射的底层实现要么基于<code class="highlighter-rouge">哈希表</code>，或者<code class="highlighter-rouge">基于平衡树</code>，其中基于平衡树的映射内部是<code class="highlighter-rouge">有序的</code>。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>scala&gt; val sortedMap = collection.immutable.SortedMap('c'-&gt;3,'b'-&gt;2,'e'-&gt;5,'a'-&gt;1)
sortedMap: scala.collection.immutable.SortedMap[Char,Int] = Map(a -&gt; 1, b -&gt; 2, c -&gt; 3, e -&gt; 5)
</code></pre>
</div>

<p>Scala目前基于平衡树的映射只提供了<code class="highlighter-rouge">不可变版本</code>，<strong>构建可变有序映射可借助Java的TreeMap</strong></p>

<p>8)可变映射中，若要<code class="highlighter-rouge">构建维持元素插入顺序的映射可</code>通过<code class="highlighter-rouge">LinkedHashMap</code>，通过scala.collection.JavaConversions.MapAsScalaMap可将Java的Map转换为Scala类型的Map；通过scala.collection.JavaConversions.MapAsJavaMap可将Scala的映射转换为Java类型的映射。</p>

<p>9)toMap方法可以将<code class="highlighter-rouge">对偶组成的集合</code>转换为<code class="highlighter-rouge">映射</code></p>

<div class="highlighter-rouge"><pre class="highlight"><code>scala&gt; val mapArr = Array((1,'a'),(2,'b'),(3,'c'))
mapArr: Array[(Int, Char)] = Array((1,a), (2,b), (3,c))

scala&gt; mapArr.toMap
res31: scala.collection.immutable.Map[Int,Char] = Map(1 -&gt; a, 2 -&gt; b, 3 -&gt; c)
</code></pre>
</div>

<p>Scala的immutable
collection并没有添加和删除元素的操作，其定义+（List使用::在头部添加）操作都是生成一个新的集合，而要删除一个元素一般使用.filterNot函数来映射一个新的集合实现。</p>

<p>（注：Scala中也scala.collection.mutable._集合，它定义了不可变集合的相应可变集合版本。一般情况下，除非一性性能优先的操作（其实Scala集合采用了共享变量的优化，生成一个新集合并不会生成所有元素的副本，它将会和老的集合共享大元素。因为Scala中变量默认都是不可变的），推荐还是采用不可变集合。因为它更直观、线程安全，你可以确定你的变量不会在其它地方被不小心的更改。）</p>

<h4 id="section-14">3.元组</h4>

<p>1.元组是<code class="highlighter-rouge">不同类型的值</code>的聚集，<code class="highlighter-rouge">对偶</code>是最简单的元组.</p>

<p>2.元组表示：通过将不同的值<code class="highlighter-rouge">用小括号</code>括起来，即表示元组。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>scala&gt; (1,2.1,'a',"helloworld")
res14: (Int, Double, Char, String) = (1,2.1,a,helloworld)
</code></pre>
</div>

<p>上例中的元组的类型就是(Int,Double,Char,String);元组中可以存放<code class="highlighter-rouge">不同类型的值</code>。</p>

<p>3.元组的访问</p>

<p>3.1)元组中的元素称为<code class="highlighter-rouge">组元</code>，可通过_1,_2,_3的形式来访问对应下标的组元。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>scala&gt; val tuple = (1,2.3,'c',"hello world")
tuple: (Int, Double, Char, String) = (1,2.3,c,hello world)

scala&gt; tuple.
_1   _3   canEqual   equals     productArity     productIterator   toString
_2   _4   copy       hashCode   productElement   productPrefix

scala&gt; tuple._1
res15: Int = 1

scala&gt; tuple._4
res16: String = hello world
</code></pre>
</div>

<font color="red">note元组的中下标是从1开始的。</font>

<p>3.2)通过模式匹配来访问元组中的值</p>

<div class="highlighter-rouge"><pre class="highlight"><code>scala&gt; val (i,d,c,str) = tuple
i: Int = 1
d: Double = 2.1
c: Char = a
str: String = helloworld
</code></pre>
</div>

<p><strong>忽略不需要的值</strong>,在模式匹配时，通过_(万能匹配符)来为需要获取值的组元<code class="highlighter-rouge">占位</code>，每个_仅可以为一个组员占位。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>scala&gt; val (i,_,_,str) = tuple
i: Int = 1
str: String = helloworld
</code></pre>
</div>

<p>4.元组可用于函数返回多个值</p>

<div class="highlighter-rouge"><pre class="highlight"><code>scala&gt; def fun():(Int,String)={
	     | (0,"hello world")
	          |
}
fun: ()(Int, String)
</code></pre>
</div>

<p>上例中，<code class="highlighter-rouge">函数定义返回值</code>类型为<code class="highlighter-rouge">元组</code>(Int,String).</p>

<h4 id="list">4.List</h4>

<p>python中，常用的集合类型：list,tuple,set,dict.Scala中对应的是:List,Tuple[X],Set,Map.</p>

<p>Scala中List是一个<code class="highlighter-rouge">递归不可变集合</code>，它很精妙的使用<code class="highlighter-rouge">递归</code>结构定义了一个列表集合。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>scala&gt;val list = 1::2::3::4::5::Nil
list:List[Int] = List(1,2,3,4,5)
</code></pre>
</div>

<p>List采用<code class="highlighter-rouge">前缀</code>操作的方式(所有的操作都在列表的顶端)进行，::操作符的作用是将一个元素和列表连接起来，并把元素放在<code class="highlighter-rouge">列表的开头</code>，这样List的操作就可以定义成一个<code class="highlighter-rouge">递归操作</code>。添加一个元素就是把元素加到list的开头，List只需要<code class="highlighter-rouge">改下头指针</code>，而删除一个元素就是把List的头指针指向列表中的第二个元素。这样，List的实现就非常的高效，它也不需要对内存做任何的转移操作。List有很多常用的方法</p>

<div class="highlighter-rouge"><pre class="highlight"><code>scala&gt; list.indexOf(3)
res6: Int = 2

scala&gt; 0 :: list
res8: List[Int] = List(0, 1, 2, 3, 4, 5)

scala&gt; list.reverse
res9: List[Int] = List(5, 4, 3, 2, 1)

scala&gt; list.filter(item =&gt; item == 3)
res11: List[Int] = List(3)

scala&gt; list
res12: List[Int] = List(1, 2, 3, 4, 5)

scala&gt; val list2 = List(4, 5, 6, 7, 8, 9)
list2: List[Int] = List(4, 5, 6, 7, 8, 9)

scala&gt; list.intersect(list2)
res13: List[Int] = List(4, 5)

scala&gt; list.union(list2)
res14: List[Int] = List(1, 2, 3, 4, 5, 4, 5, 6, 7, 8, 9)

scala&gt; list.diff(list2)
res15: List[Int] = List(1, 2, 3)
</code></pre>
</div>

<p>Scala中默认都是<code class="highlighter-rouge">Immutable collection</code>，在集合上定义的操作都<code class="highlighter-rouge">不会更改集合本身</code>，而是生成一个<code class="highlighter-rouge">新的集合</code>。Python中只有set上有求交、并、差积运算，Scala中将其范化到所以序列集合上（Seq、List、Set、Array……）都可以支持。</p>

<h4 id="set">5.Set</h4>

<p>Set是一个<code class="highlighter-rouge">不重复且无序的</code>集合，初始化一个Set需要使用Set对象:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>scala&gt; val set = Set("Python", "Scala", "Java", "C++", "Javascript", "C#", "PHP")
set: scala.collection.immutable.Set[String] = Set(Scala, C#, Python, Javascript, PHP, C++, Java)

scala&gt; set + "Go"
res21: scala.collection.immutable.Set[String] = Set(Scala, C#, Go, Python, Javascript, PHP, C++, Java)

scala&gt; set filterNot (item =&gt; item == "PHP")
res22: scala.collection.immutable.Set[String] = Set(Scala, C#, Python, Javascript, C++, Java)
</code></pre>
</div>

<h4 id="section-15">6.类</h4>

<p>1)Scala中的类是<code class="highlighter-rouge">公有可见性</code>的，且多个类可以包含在同一个源文件中。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>class Counter{
	private var value = 0	//类成员变量必须初始化，否则报错 `
	def increment(){		//类中的方法默认是公有可见性
		value += 1
	}

	def current() = value	//类中的取值方法，在定义时可省略括号，直接 def current = value
}
</code></pre>
</div>

<p>类的使用</p>

<div class="highlighter-rouge"><pre class="highlight"><code>scala&gt; class Counter{
	     | private var value = 0
		 | def increment(){
		 	     | value += 1
	 	          |
		 }
      | def current = value
      |
}
defined class Counter
scala&gt; var counter = new Counter
counter: Counter = Counter@619bfe29
scala&gt; counter.current
res0: Int = 0
scala&gt; counter.increment
scala&gt; counter.current
res2: Int = 1
</code></pre>
</div>

<p>Scala的类在<code class="highlighter-rouge">未提供构造器时</code>，也会提供<code class="highlighter-rouge">默认构造器</code>；且在调用无参构造器或无参方法可<code class="highlighter-rouge">省略方法后的括号</code></p>

<p>2)Scala类中的每个<code class="highlighter-rouge">字段</code>都有<code class="highlighter-rouge">geter</code>和<code class="highlighter-rouge">setter</code>方法，<code class="highlighter-rouge">私有字段</code>的<code class="highlighter-rouge">getter</code>和<code class="highlighter-rouge">setter</code>默认是<code class="highlighter-rouge">私有的</code>，公有字段的<code class="highlighter-rouge">getter</code>和<code class="highlighter-rouge">setter</code>默认是公有的。其中对于类中的属性value，Scala类默认生成的getter方法名为<code class="highlighter-rouge">value</code>,默认生成的setter方法名为<code class="highlighter-rouge">value_=</code>.使用时，我们可以重新定义获取或设置属性的方法。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>scala&gt; class Clock{
     | var hour = 0
     | var minute = 0
     | var second = 0
  		 | def getTime():String = {
     | return hour + ":" + minute +":"+second
		}
}
defined class Clock
</code></pre>
</div>

<p>对于Clock类中的属性，如hour，其对应的getter方法为hour，其对应的setter方法名为<code class="highlighter-rouge">hour_=</code></p>

<div class="highlighter-rouge"><pre class="highlight"><code>scala&gt; var clock = new Clock()
clock: Clock = Clock@7ff6804a

scala&gt; clock.hour
res4: Int = 0

scala&gt; clock.hour_=(12)

scala&gt; clock.hour
res6: Int = 12
</code></pre>
</div>

<p>注意：<code class="highlighter-rouge">可以重新定义获取Scala类中属性的方法</code>，但是最好不要与属性<code class="highlighter-rouge">默认对应的getter/setter方法重名</code>，否则会报错。</p>

<p>3)对于Scala类总的val属性，只有默认的getter方法；对于private属性，其默认getter，setter都是private的，因而，对于不想提供setter方法的变量可以设置为val，对于不想提供getter，setter方法的变量可以设置为private.</p>

<p>4)注意，Scala类中，定义函数时，若函数声明<code class="highlighter-rouge">省略了</code>函数名<code class="highlighter-rouge">后的括号</code>(由于无参数，可以省略)，必须参数<code class="highlighter-rouge">无括号</code>的形式，通过带括号形式<code class="highlighter-rouge">调用会报错</code></p>
<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Counter</span><span class="o">{</span>
	<span class="k">var</span>		<span class="n">value</span> <span class="k">=</span> <span class="mi">0</span>

	<span class="k">def</span> <span class="n">current</span> <span class="k">=</span> <span class="n">value</span>
<span class="o">}</span>
</code></pre>
</div>

<p>在类Counter定义中，对于方法current,由于不接受参数，所以定义时，省略了方法名current后的<code class="highlighter-rouge">括号</code>。此时，对于Counter的实例counter，调用current方法时，必须采用counter.current(无括号形式)</p>

<p>5)构造器</p>

<p>Scala的类可以有一个<code class="highlighter-rouge">主构造器</code>和<code class="highlighter-rouge">多个辅助构造器</code>。多个辅助构造器的名称为this，每一个辅助构造器都必须以调用已经定义的辅助构造器或主构造器开始定义。</p>

<ul>
  <li>主构造器</li>
</ul>

<p>如果一个类<code class="highlighter-rouge">没有显示定义主构造器</code>，则有一个默认的<code class="highlighter-rouge">无参主构造器</code>。如：</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Student</span><span class="o">(</span><span class="k">val</span> <span class="n">name</span><span class="k">:</span><span class="kt">String</span><span class="o">,</span> <span class="k">var</span> <span class="n">age</span><span class="k">:</span><span class="kt">Int</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">address</span><span class="k">:</span><span class="kt">String</span> <span class="o">=</span> <span class="s">""</span><span class="o">,</span> <span class="k">private</span> <span class="k">var</span> <span class="n">school</span><span class="k">:</span><span class="kt">String</span> <span class="o">=</span> <span class="s">""</span><span class="o">){</span>
	<span class="k">var</span> <span class="n">grade</span><span class="k">:</span><span class="kt">Int</span> <span class="o">=</span> <span class="k">if</span><span class="o">(</span> <span class="n">age</span><span class="o">&gt;</span><span class="mi">7</span>  <span class="o">)</span> <span class="n">age</span><span class="o">-</span><span class="mi">7</span> <span class="k">else</span> <span class="mi">0</span>

	<span class="n">println</span><span class="o">(</span><span class="s">" I'm in main constructor. "</span><span class="o">)</span>

	<span class="k">def</span> <span class="n">info</span><span class="o">()</span> <span class="k">=</span> <span class="s">""</span>
<span class="o">}</span>
</code></pre>
</div>

<p>对于Scala类，<code class="highlighter-rouge">主构造器的参数</code>放置在类名后，由<code class="highlighter-rouge">括号</code>括起来。且对于<code class="highlighter-rouge">主构造器中var、val、private</code>等标注的参数，都会成为类的对应字段，并生成对应的<code class="highlighter-rouge">默认getter、setter方法</code>。如Student类中的name、age、school等。对于主构造器中的未用var、val标注的参数，如果在类的任何一个方法用用到该参数，该参数将会转换为类的字段，否则不会，如Student类的address属性。</p>

<p>由于在Student类中的info方法中用到了参数address，所以Student共有name、age、address、school、grade等5个属性，且Scala根据对应属性的特点生成了默认的getter和setter方法。</p>

<p><strong>对于主构造器的参数，也可以提供参数默认值。通过为主构造器提供默认值可减少辅助构造器的个数</strong>.主构造器的函数体，是类中除了方法定义以外的其他语句，如在Student类的主构造器中，包含grade属性的初始化和prinln这两行语句。</p>

<p>6)辅助构造器</p>

<p>辅助构造器通过this来定义，且必须首先调用<code class="highlighter-rouge">主构造器</code>或者其他<code class="highlighter-rouge">已经定义的辅助构造器</code>。</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Person</span><span class="o">(</span><span class="k">val</span> <span class="n">name</span><span class="k">:</span><span class="kt">String</span><span class="o">){</span>
	 <span class="k">var</span> <span class="n">age</span> <span class="k">=</span> <span class="mi">0</span>
	 <span class="k">var</span> <span class="n">sex</span><span class="k">:</span><span class="kt">Char</span> <span class="o">=</span> <span class="sc">'f'</span>

    <span class="n">println</span><span class="o">(</span><span class="s">"main constructor..."</span><span class="o">)</span>

     <span class="k">def</span> <span class="k">this</span><span class="o">(</span><span class="n">name</span><span class="k">:</span><span class="kt">String</span><span class="o">,</span>  <span class="n">age</span><span class="k">:</span><span class="kt">Int</span><span class="o">){</span>
	       <span class="k">this</span><span class="o">(</span><span class="n">name</span><span class="o">)</span>        <span class="c1">//调用主构造器
</span>	        <span class="k">this</span><span class="o">.</span><span class="n">age</span> <span class="k">=</span> <span class="n">age</span>     <span class="c1">//使用this关键字
</span>	         <span class="n">println</span><span class="o">(</span><span class="s">" auxiliary constructor1 "</span><span class="o">)</span>

	<span class="o">}</span>
	   <span class="k">def</span> <span class="k">this</span><span class="o">(</span><span class="n">name</span><span class="k">:</span><span class="kt">String</span><span class="o">,</span> <span class="n">age</span><span class="k">:</span><span class="kt">Int</span><span class="o">,</span> <span class="n">sex</span><span class="k">:</span><span class="kt">Char</span><span class="o">){</span>
	          <span class="k">this</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">age</span><span class="o">)</span>
	          <span class="k">this</span><span class="o">.</span><span class="n">sex</span> <span class="k">=</span> <span class="n">sex</span>
	          <span class="n">println</span><span class="o">(</span><span class="s">" auxiliary constructor2 "</span><span class="o">)</span>
	 <span class="o">}</span>
<span class="o">}</span>
</code></pre>
</div>

<p>note：辅助构造器的参数前<code class="highlighter-rouge">不能添加val,var,标志</code>，否则会<code class="highlighter-rouge">报错</code>。</p>

<p>7)私有构造器</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Person</span> <span class="k">private</span><span class="o">(</span><span class="k">val</span> <span class="n">name</span><span class="k">:</span><span class="kt">String</span><span class="o">){</span>
  <span class="k">var</span> <span class="n">age</span><span class="k">:</span><span class="kt">Int</span> <span class="o">=</span> <span class="mi">1</span>

  <span class="k">def</span> <span class="k">this</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">age</span><span class="k">:</span><span class="kt">Int</span><span class="o">){</span>
         <span class="k">this</span><span class="o">(</span><span class="n">name</span><span class="o">)</span>
         <span class="k">this</span><span class="o">.</span><span class="n">age</span> <span class="k">=</span> <span class="n">age</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre>
</div>

<p>私有构造器通过在类名后<code class="highlighter-rouge">用private关键字</code>标注主构造器参数来表明，此时，可以通过辅助构造器<code class="highlighter-rouge">来创建该类的对象</code>。</p>

<p>8)嵌套类</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Family</span><span class="o">(</span><span class="k">val</span> <span class="n">h_name</span><span class="k">:</span><span class="kt">String</span><span class="o">,</span> <span class="k">val</span> <span class="n">w_name</span><span class="k">:</span><span class="kt">String</span><span class="o">){</span>
	<span class="k">class</span> <span class="nc">Husband</span><span class="o">(</span><span class="k">var</span> <span class="n">name</span><span class="k">:</span><span class="kt">String</span><span class="o">){</span>
         <span class="n">println</span><span class="o">(</span><span class="s">" I'm a husband "</span><span class="o">)</span>
	<span class="o">}</span>

	<span class="k">class</span> <span class="nc">Wife</span><span class="o">(</span><span class="k">var</span> <span class="n">name</span><span class="k">:</span><span class="kt">String</span><span class="o">){</span>
	        <span class="n">println</span><span class="o">(</span><span class="s">" I'm a Wife "</span><span class="o">)</span>
	 <span class="o">}</span>

	 <span class="k">var</span> <span class="n">husband</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Husband</span><span class="o">(</span><span class="n">h_name</span><span class="o">)</span>
	 <span class="k">var</span> <span class="n">wife</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Wife</span><span class="o">(</span><span class="n">w_name</span><span class="o">)</span>

	 <span class="k">def</span> <span class="n">info</span><span class="o">(){</span>
	        <span class="n">println</span><span class="o">(</span> <span class="s">"husband: "</span><span class="o">+</span><span class="n">husband</span><span class="o">.</span><span class="n">name</span><span class="o">+</span><span class="s">", wife:"</span><span class="o">+</span><span class="n">wife</span><span class="o">.</span><span class="n">name</span>  <span class="o">)</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre>
</div>
<p>在Scala中，你几乎可以在<code class="highlighter-rouge">任何语法结构</code>中<code class="highlighter-rouge">嵌套语法结构</code>，如在<code class="highlighter-rouge">函数中定义函数，在类中定义类</code>。</p>

<h4 id="section-16">7.对象</h4>

<p>1)Scala中没有<code class="highlighter-rouge">静态方法</code>和<code class="highlighter-rouge">静态字段</code>，但是可以用<code class="highlighter-rouge">object</code>语法来实现类似的功能。对象定义某个类的单个实例。Scala的object中可以实现类似的功能，用来存放<code class="highlighter-rouge">工具函数或常量</code>等。</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">object</span> <span class="nc">Sequence</span><span class="o">{</span>
		<span class="k">private</span> <span class="k">var</span> <span class="n">next_num</span> <span class="k">=</span> <span class="mi">0</span>
		<span class="k">val</span> <span class="n">threshold</span> <span class="k">=</span> <span class="mi">100</span>

		<span class="k">def</span> <span class="n">getSequence</span><span class="o">()</span> <span class="k">=</span> <span class="o">{</span>
			<span class="n">next_num</span> <span class="o">+=</span> <span class="mi">1</span>
			<span class="n">next_num</span>
	<span class="o">}</span>
<span class="o">}</span>

</code></pre>
</div>
<p>使用object中的常量或方法，通过object名直接调用，对象构造器在对象<code class="highlighter-rouge">第一次被使用</code>时调用(如果某对象一直<code class="highlighter-rouge">未被使用</code>，那么其构造器也不会被<code class="highlighter-rouge">调用</code>)</p>

<p>object的构造器<code class="highlighter-rouge">不接受参数传递</code></p>

<div class="highlighter-rouge"><pre class="highlight"><code>scala&gt; Seq.getSequence
res4:	Int = 1
scala&gt; Seq.threshold
res5:	Int = 100
</code></pre>
</div>

<p>2)伴生对象</p>

<p>可以将在Scala中定义的<code class="highlighter-rouge">静态常量、方法等</code>放置到Scala的类的伴生对象中，伴生对象与<code class="highlighter-rouge">类同名</code>，且<code class="highlighter-rouge">必须放置同一个源文件中</code>。类可以访问伴生对象私有属性，但是必须通过<code class="highlighter-rouge">伴生对象.属性名</code>或<code class="highlighter-rouge">伴生对象.方法</code>调用</p>

<p><strong>伴生对象是类的一个<code class="highlighter-rouge">特殊实例</code></strong></p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Counter</span><span class="o">{</span>
     <span class="k">def</span> <span class="n">getTotalCounter</span><span class="o">()</span><span class="k">=</span> <span class="nc">Counter</span><span class="o">.</span><span class="n">getCount</span>
<span class="o">}</span>
<span class="k">object</span> <span class="nc">Counter</span><span class="o">{</span>
     <span class="k">private</span> <span class="k">var</span> <span class="n">cnt</span> <span class="k">=</span> <span class="mi">0</span>
     <span class="k">private</span> <span class="k">def</span> <span class="n">getCount</span><span class="o">()</span><span class="k">=</span> <span class="n">cnt</span>
<span class="o">}</span>
</code></pre>
</div>

<p>如在类Counter方法其伴生对象的使用方法getCount，必须通过Counter.getCount()的方式调用。</p>

<p>3)对象可以继承或扩展多个特质</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Person</span><span class="o">(</span><span class="k">var</span> <span class="n">name</span><span class="k">:</span><span class="kt">String</span><span class="o">,</span> <span class="k">var</span> <span class="n">age</span><span class="k">:</span><span class="kt">Int</span><span class="o">){</span>
     <span class="k">def</span> <span class="n">info</span><span class="o">()</span><span class="k">:</span><span class="kt">Unit</span>
<span class="o">}</span>
<span class="k">object</span> <span class="nc">XiaoMing</span> <span class="k">extends</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"XiaoMing"</span><span class="o">,</span> <span class="mi">5</span><span class="o">){</span>
     <span class="k">def</span> <span class="n">info</span><span class="o">(){</span>
        <span class="n">println</span><span class="o">(</span><span class="s">"name is"</span> <span class="o">+</span><span class="n">naem</span> <span class="o">+</span><span class="s">",age is "</span> <span class="o">+</span> <span class="n">age</span><span class="o">)</span>
	<span class="o">}</span>
<span class="o">}</span>

</code></pre>
</div>

<p>4)apply方法</p>

<p>当遇到object(参数1，参数2，…,参数n)的形式的调用时，apply方法便会调用。</p>

<p>5)main方法–Scala程序的入口</p>

<p>main方法定义在object中，形式如下</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">object</span>  <span class="nc">Hello</span><span class="o">{</span>
	<span class="k">def</span> <span class="n">main</span><span class="o">(</span><span class="n">args</span><span class="k">:</span><span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">]){</span>
		<span class="n">println</span><span class="o">(</span><span class="s">"hello world"</span><span class="o">)</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre>
</div>

<p>可以通过scalac 源文件名，然后通过scala 类名来执行主程序</p>

<p>6)还可以通过<code class="highlighter-rouge">扩展特质App</code>来运行指定代码</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">object</span> <span class="nc">hello</span> <span class="n">extens</span> <span class="nc">App</span><span class="o">{</span>
	<span class="n">println</span><span class="o">(</span><span class="s">"A `hello world` from hello world"</span><span class="o">)</span>
<span class="o">}</span>
</code></pre>
</div>
<p>通过扩展App特质的方式执行程序，将要执行的程序放到了object的主构造器中。</p>

<p>7)枚举</p>

<p>Scala并没有定义枚举类型，但是可以通过定义扩展Enumeration的对象，并用value方法初始化枚举中所有可选的值，提供枚举。</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">object</span> <span class="nc">TrafficeLight</span> <span class="k">extends</span> <span class="nc">Enumeration</span><span class="o">{</span>
	<span class="k">val</span> <span class="nc">Red</span><span class="o">,</span><span class="nc">Yellow</span><span class="o">,</span><span class="nc">Green</span> <span class="k">=</span> <span class="n">value</span>
<span class="o">}</span>
</code></pre>
</div>

<p>上述实例中的 val Red,Yellow,Green = value语句，相当于</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">val</span> <span class="n">red</span> <span class="k">=</span> <span class="n">value</span>
<span class="k">val</span> <span class="nc">Yellow</span> <span class="k">=</span> <span class="n">value</span>
<span class="k">val</span> <span class="nc">Green</span> <span class="k">=</span> <span class="n">value</span>
</code></pre>
</div>

<p>用value方法来<code class="highlighter-rouge">初始化枚举类变量</code>时，value方法会返回内部类的新实例，且该内部类也叫value。另外，在调用value方法时，可传入<code class="highlighter-rouge">ID，名称</code>两个参数。如果没有指定ID，默认<code class="highlighter-rouge">从0开始，后面参数的ID加1</code>，如果未指定名称，默认与属性字段同名。</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">object</span> <span class="nc">TrafficLight</span> <span class="k">extends</span> <span class="nc">Enumeration</span><span class="o">{</span>
	<span class="k">val</span> <span class="nc">Red</span> <span class="k">=</span> <span class="n">value</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="s">"stop"</span><span class="o">)</span>
	<span class="k">val</span> <span class="nc">Yellow</span> <span class="k">=</span> <span class="n">value</span><span class="o">(</span><span class="s">"wait"</span><span class="o">)</span><span class="c1">// 可以单独传名字
</span>	<span class="k">val</span> <span class="nc">Green</span> <span class="k">=</span> <span class="n">value</span><span class="o">(</span><span class="mi">4</span><span class="o">)</span>	<span class="c1">// 可以传入ID
</span><span class="o">}</span>
</code></pre>
</div>

<p>上例中，Yellow属性就<code class="highlighter-rouge">仅定义了名称</code>，Green<code class="highlighter-rouge">仅定义ID</code></p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span><span class="nc">TrafficLight</span><span class="o">.</span><span class="nc">Red</span>
<span class="n">res10</span><span class="k">:</span><span class="kt">TrafficLight.value</span> <span class="o">=</span> <span class="nc">Stop</span>
<span class="n">scala</span><span class="o">&gt;</span><span class="nc">TrafficLight</span><span class="o">.</span><span class="nc">Green</span>
<span class="n">res11</span><span class="k">:</span><span class="kt">TrafficLight.value</span> <span class="o">=</span> <span class="nc">Green</span>
</code></pre>
</div>

<p>参数在<code class="highlighter-rouge">不指定名称</code>时，默认参数的value为<code class="highlighter-rouge">字段名</code></p>

<p><strong>note:枚举类型的值是对象的value,如上面中的枚举类型是TrafficLight.value</strong></p>

<p>8)通过id方法来获取枚举类型值的ID</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span><span class="nc">TrafficLight</span><span class="o">.</span><span class="nc">Green</span><span class="o">.</span><span class="n">id</span>
<span class="n">res12</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">4</span>
</code></pre>
</div>

<p>9)通过values方法获取所有枚举值的集合</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span><span class="nc">TrafficLight</span><span class="o">.</span><span class="n">values</span>
<span class="n">res13</span><span class="k">:</span><span class="kt">TrafficLight.ValueSet</span> <span class="o">=</span> <span class="nc">TrafficLight</span><span class="o">.</span><span class="nc">ValueSets</span><span class="o">(</span><span class="nc">Stop</span><span class="o">,</span><span class="nc">Wait</span><span class="o">,</span><span class="nc">Green</span><span class="o">)</span>
</code></pre>
</div>

<p>10)通过ID来获取对应的枚举对象</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span><span class="nc">TrafficLight</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
<span class="n">res14</span><span class="k">:</span><span class="kt">TrafficLight.value</span> <span class="o">=</span> <span class="nc">Stop</span>
</code></pre>
</div>

<h4 id="section-17">8.函数</h4>

<p>在Scala中，函数是一等公民。函数可以像类型一样被赋值给一个变量，也可以做为一个函数的参数被传入，甚至还可以做为函数的返回值返回（这就是函数式编程）。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>scala&gt; def calc(n1: Int, n2: Int): (Int, Int) = {
		|   (n1 + n2, n1 * n2)
			|
}
calc: (n1: Int, n2: Int)(Int, Int)

scala&gt; val (add, sub) = calc(5, 1)
add: Int = 6
sub: Int = 5
</code></pre>
</div>

<p>这里定义了一个函数：calc，它有两个参数：n1和n2，其类型为：Int。cala函数的返回值类型是一个有两个元素的元组，在Scala中可以简写为：(Int,
Int)。在Scala中，代码段的最后一句将做为函数返回值，所以这里不需要显示的写return关键字。</p>

<p>而val (add, sub) = calc(5,
1)一句，是Scala中的抽取功能。它直接把calc函数返回的一个Tuple2值赋给了add他sub两个变量。</p>

<h3 id="scala-api-download">Scala API download</h3>

<p>只要我们按照如下的格式，就可以下载到对于版本的API了。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>http://downloads.typesafe.com/scala/{version}/scala-docs-{version}.txz
http://downloads.typesafe.com/scala/{version}/scala-docs-{version}.zip
</code></pre>
</div>

<p>example:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>axel -n 10 http://downloads.typesafe.com/scala/2.11.8/scala-docs-2.11.8.txz
axel -n 10 http://downloads.typesafe.com/scala/2.11.8/scala-docs-2.11.8.zip
</code></pre>
</div>


					<div class="meta">
						<p class="date-publish">
							Published: 
							<date class="date-pub" title="2016-10-19T00:00:00+08:00" datetime="2016-10-19T00:00:00+08:00" pubdate>
							<span class="month"><abbr>October</abbr></span>
							<span class="day">19</span>
							<span class="year">2016</span>
							</date>
						</p>
						<ul class="list-category list-linear">
							<li class="list-head">category: </li>
							
							


  
     
    	<li><a href="/categories.html#Scala-ref">
    		Scala <span>2</span>
    	</a></li>
    
  


						</ul>
						<ul class="list-tag list-linear">
							<li class="list-head">tags: </li>
							
							


  
     
    	<li><a href="/tags.html#scala sbt-ref">scala sbt <span>1</span></a></li>
    
  



						</ul>
					</div><!-- meta -->
				</div><!-- entry-content -->
				<div class="misc-content">
					<div class="social">
						<ul class="list-linear">
							<li><div class="twitter-tweet"><a href="https://twitter.com/share" class="twitter-share-button" data-count="horizontal" data-via="liangkangkang" data-lang="en">Tweet</a></div></li>
							<li><div class="twitter-follow"><a href="https://twitter.com/liangkangkang" class="twitter-follow-button" data-show-count="false" data-lang="en"></a></div></li>
						</ul>
					</div>
					<div class="comment">
					


  <div id="disqus_thread"></div>
<script type="text/javascript">
    
    var disqus_developer = 1;
    var disqus_shortname = 'jekyllbootstrap'; // required: replace example with your forum shortname
    
    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Liangkangkang.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Liangkangkang</span></a>




					</div>
				</div><!-- misc-content -->
			</div><!-- bd -->
			<footer class="unit-foot">
				<div class="unit-inner unit-foot-inner">
					<nav class="pagination">
						<ul>
							
							<li class="prev"><a class="internal" rel="prev"  href="/elk/2016/10/16/elk" title="View Elk">&laquo; Elk</a></li>
							
							
							<li class="pipe"> | </li>
							
							
							<li class="next"><a class="internal" rel="next"  href="/tools/2016/10/21/out-of-wall" title="View Out Of Wall">Out Of Wall &raquo;</a></li>
							
						</ul>
					</nav>
					<p class="gotop">
						<a href="#page">Back to Top</a>
					</p>
				</div>
			</footer>

		</div><!-- content -->
	</div><!-- unit-inner -->
</article>


				</div>
			</div><!-- unit-inner -->
		</div><!-- unit-body -->
	</div><!-- body -->
	<footer class="the-footer">
		<div class="unit-foot">
			<div class="unit-inner unit-foot-inner">
				<div class="misc vcard">
					<h4>about</h4>
					<ul>
						<li class="contact"><address><span class="author fn n">kangkangliang</span> - <span class="fn email">lkkforworld@gmail.com</span></address></li>
						<li class="github"><a href="http://github.com/lkkandsyf/" rel="me">github.com/lkkandsyf</a></li>
						<li class="twitter"><a href="http://twitter.com/liangkangkang/" rel="me">twitter.com/liangkangkang</a></li>
						<li class="rss"><a href="http://feeds.feedburner.com/">Subscribe to RSS Feed</a></li>
					</ul>
				</div><!-- misc -->
			</div><!-- unit-foot-inner -->
		</div><!-- unit-foot -->
	</footer>
</div><!-- page -->
<script>
	(function(d, s) {
		var js, fjs = d.getElementsByTagName(s)[0], load = function(url, id) {
		if (d.getElementById(id)) {return;}
		js = d.createElement(s); js.src = url; js.id = id;
		fjs.parentNode.insertBefore(js, fjs);
		};
	load('//platform.twitter.com/widgets.js', 'tweetjs');
	// load('https://apis.google.com/js/plusone.js', 'gplus1js'); // Checkout http://j.mp/ApDgMr for usage html for this is <div class="g-plusone" data-size="medium"></div>
	// load('//connect.facebook.net/en_US/all.js#xfbml=1', 'fbjssdk'); // Checkout http://j.mp/wZw2xR for using open graph protorol html for this is <div class="fb-like" data-href="/scala/2016/10/19/learn-scala" data-send="false" data-layout="button_count" data-width="450" data-show-faces="false" data-font="verdana"></div>
	}(document, 'script'));
</script>
<script>
/*! A fix for the iOS orientationchange zoom bug.Script by @scottjehl, rebound by @wilto. MIT License.*/
(function(j){var i=j.document;if(!i.querySelectorAll){return}var l=i.querySelectorAll("meta[name=viewport]")[0],a=l&&l.getAttribute("content"),h=a+", maximum-scale=1.0",d=a+", maximum-scale=10.0",g=true,c=j.orientation,k=0;if(!l){return}function f(){l.setAttribute("content",d);g=true}function b(){l.setAttribute("content",h);g=false}function e(m){c=Math.abs(j.orientation);k=Math.abs(m.gamma);if(k>8&&c===0){if(g){b()}}else{if(!g){f()}}}j.addEventListener("orientationchange",f,false);j.addEventListener("deviceorientation",e,false)})(this);
</script>

  



</body>
</html>

